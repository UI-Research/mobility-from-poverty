---
title: "Share of households with broadband access"
author: "Ridhi Purohit"
date: now
format:
  html:
    embed-resources: true
    toc: true
    toc_float: true
    code-fold: show
    code-tools: true
editor_options: 
  chunk_output_type: console
execute:
  warning: false
---

```{=html}
<style>
@import url('https://fonts.googleapis.com/css?family=Lato&display=swap');
</style>
```
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

This document programs the **Digital Access** metric which encapsulates a ratio of households with the presence of a computer (laptop, desktop, notebook computer, tablet, or portable wireless computer) and broadband (high speed) internet service in the household. An overall ratio is calculated, as well as by racial subgroup (measured according to the race of each head of the household) and income subgroup.

## Process

-   [Housekeeping](#housekeeping)
-   [Get IPUMS Data](#get-ipums-data)
-   [Format Data](#format-data)
-   [Merge Crosswalk](#merge-crosswalk)
-   [Create Metric](#create-metric)
-   [Explore Metric](#explore-metric)
-   [Metric Quality](#metric-quality)
-   [Evaluate Metric](#evaluate-metric)
-   [Final Data](#final-data)

## Housekeeping {#sec-housekeeping}

```{r}
#| label: setup

options(scipen = 999)
librarian::shelf(
  tidyverse,
  ipumsr,
  here,
  UrbanInstitute / urbnthemes,
  tidylog,
  warn.conflicts = FALSE
  )
set_urbn_defaults(style = "print")

source(here::here("functions", "testing", "evaluate_final_data.R"))

```

**Instructions to run this code book**

-   This Quarto markdown document uses the `here` R library to set and access file paths. Please check your root directory by executing `here::here()` to verify that it points to the root folder of the `mobility-from-poverty` GitHub repository.
-   To avoid manually setting up file paths, open the GitHub repository as an R project by leveraging the `mobility-from-poverty.Rproj` file present in the root folder of the `mobility-from-poverty` GitHub repository when you clone it.
-   Un-comment all of the code in @lst-query-ipums-api code block (lines 68 through 111) when you run the code in this file for the first time to download the IPUMS data.
-   In @lst-load-ipums code block, you'd be asked to update the microdata file name (line number 128) that you download through the @lst-query-ipums-api block, so please make a note of it.

## Get IPUMS Data {#sec-get-ipums-data}

This code book uses the 2017-2021 5-year ACS extract from the IPUMS API using R package `ipumsr`. To access this data, an IPUMS API key is required. This can be obtained by registering on the [IPUMS USA](https://uma.pop.umn.edu/usa/user/new?return_url=https%3A%2F%2Fusa.ipums.org%2Fusa-action%2Fmenu) website and creating an API key. For more information see the `ipumsr` [getting started vignette](https://tech.popdata.org/ipumsr/articles/ipums.html).

```{r}
#| label: query-ipums-api
#| lst-label: lst-query-ipums-api
#| lst-cap: Query IPUMS API
#| cache: true

# Run the code in this block the first time this notebook is executed to get the 
# data and avoid repeated downloads 

# define variables to be queried from IPUMS API

# NOTE: running var_spec("CIHISPEED", data_quality_flags = TRUE) produced following error: Error in `ipums_api_request()`: 
# ! API request failed with status 400.
# âœ– CIHISPEED has data quality flags, but none are available in the selected samples

# acs_vars <- list("YEAR", "MULTYEAR", "SAMPLE", "SERIAL", "CBSERIAL", "HHWT", 
#              "CLUSTER", "STRATA", "GQ", "REGION", "STATEFIP", "COUNTYFIP", "PUMA",
#              "HHINCOME", var_spec("CILAPTOP", data_quality_flags = TRUE), 
#              var_spec("CITABLET", data_quality_flags = TRUE),
#              "CIHISPEED", "CINETHH",
#              "PERNUM", "PERWT", "RACE", "HISPAN")


# define the IPUMS extract
# acs_2021_extract <- ipumsr::define_extract_micro(
#  collection = "usa",
#  description = "2017-2021 ACS 5-yr Sample",
#  samples = "us2021c",
#  variables = acs_vars)

# submit and wait for IPUMS extract
# acs_ext_submit <- ipumsr::submit_extract(acs_2021_extract)
# acs_ext_complete <- ipumsr::wait_for_extract(acs_ext_submit)

# check if data download directory is present
fs::dir_create(here("08_education/data/raw"))

#download IPUMS extract
# data_path <- ipumsr::download_extract(
#  acs_ext_complete, 
#  download_dir = here("08_education/data/raw")
#  )

```

## Format Data {#sec-format-data}

Now, the downloaded data needs to be cleaned and formatted so that it can be used further to generate the metric. The 2017-2021 5-year ACS microdata extract for computer and internet use is in the form of household level data set with person level variables added for this analysis.

### Clean Household-Level Data

To analyze the data at the household level, only the first person sampled in the household is retained in the data.

```{r}
#| label: load-ipums
#| lst-label: lst-load-ipums
#| lst-cap: Load IPUMS Data
#| cache: true

# Manually set the file name downloaded in the previous code chunk which is 
# 'usa_00007.xml' for me but will have some different value for whoever re-runs this

micro_filepath <- "usa_00008.xml"

# load acs data and filter for household level analysis
acs5_2021_raw <- ipumsr::read_ipums_micro(
  here(paste0("08_education/data/raw/", micro_filepath))
  ) |>
  filter(PERNUM == 1)

```

The IPUMS data consists of labelled vectors ([ipumsr](https://tech.popdata.org/ipumsr/articles/value-labels.html#remove-unused-value-labels)). We find the missing labels using the `ipums_var_info(acs5_2021_raw)` and inspecting the `val_labels` column.

For the "Total household income" i.e. `HHINCOME` column, "N/A" values are denoted by `9999999` which needs to be updated before proceeding.

```{r}
#| label: handle-missingness

# re-label `HHINCOME` when value is 9999999 denoting "N/A "

acs5_2021_raw <- acs5_2021_raw |>
  mutate(
    HHINCOME = lbl_na_if(HHINCOME, ~ .lbl %in% c("N/A "))
  )

```

Since the digital access metric is at the household level, individuals who live in group quarters need to be excluded from the data. For more information, see the [variable description](https://usa.ipums.org/usa-action/variables/GQ#codes_section) on IPUMS USA.

Running `ipums_var_info(acs5_2021_raw)` shows the value labels for the group quarters variable `GQ`:

val lbl\
0 Vacant unit\
1 Households under 1970 definition\
2 Additional households under 1990 definition 3 Group quarters--Institutions\
4 Other group quarters\
5 Additional households under 2000 definition 6 Fragment

```{r}
#| label: remove-group-quarters

# Only retain people who live in housing units in the data
acs5_2021_raw <- acs5_2021_raw |>
  filter((GQ %in% c(1,2,5)))

# Check if only required GQ values remain in data
assertthat::assert_that(all(acs5_2021_raw$GQ %in% c(1, 2, 5)))
```

FIPS codes require re-formatting by padding with leading zeros so that state codes are two digits, county codes are three digits, and place codes are five digits.

```{r}
#| label: format-fips-codes

acs5_2021_raw <-
  acs5_2021_raw |>
  mutate(
    across(c(STATEFIP, COUNTYFIP, PUMA), as.character),
    STATEFIP = str_pad(STATEFIP, width = 2, pad = "0", side = "left"),
    COUNTYFIP = str_pad(COUNTYFIP, width = 3, pad = "0", side = "left"),
    PUMA = str_pad(PUMA, width = 5, pad = "0", side = "left")
  ) |>
  rename(
    STATE = STATEFIP,
    COUNTY = COUNTYFIP
  ) |>
  # Reformat the YEAR variable
  mutate(YEAR = as.integer(YEAR))
```

### Race-Ethnicity & Income Subgroups

The race-ethnicity subgroup is created by collapsing the `RACE` and `HISPAN` variables into following categories: - Black, Non-Hispanic - White, Non-Hispanic - Other Races and Ethnicities - Hispanic

Running `ipums_val_labels(acs5_2021_raw$RACE)` shows the value labels for the `RACE` variable:

| val | lbl                              |
|-----|----------------------------------|
| 1   | White                            |
| 2   | Black/African American           |
| 3   | American Indian or Alaska Native |
| 4   | Chinese                          |
| 5   | Japanese                         |
| 6   | Other Asian or Pacific Islander  |
| 7   | Other race, nec                  |
| 8   | Two major races                  |
| 9   | Three or more major races        |

We need to create a collapsed variable `RACE_mod` that takes on values `Black/African American` for `RACE` label value `2`, `White` for `RACE` label value `1`, and `Other` for all other `RACE` label values.

```{r}
#| label: create-collapsed-race

# Create new column `RACE_mod` identifying White, Black , and Other races
acs5_2021_raw <- acs5_2021_raw |>
  mutate( 
    RACE_mod = lbl_relabel(
      RACE, lbl(10, "Other") ~ .val %in% c(3, 4, 5, 6, 7, 8, 9)),
    RACE_mod = as_factor(RACE_mod),
    HISPAN = as_factor(HISPAN)
    ) 

# Check if `RACE_mod` correctly codes `RACE` by verifying their unique combinations
acs5_2021_raw |> distinct(RACE_mod, RACE)

```

`RACE_ETHNICITY` is coded by combining `RACE_mod` to specify race while ethnicity is derived from variable `HISPAN`. For any race, if `HISPAN` takes on value "Not Hispanic" then ethnicity is "Non-Hispanic" otherwise it is considered "Hispanic".

```{r}
#| label: create-subgroup-race-ethnicity

# Create `RACE_ETHNICITY` subgroup by collapsing `RACE_mod` and `HISPAN`
acs5_2021_raw <- acs5_2021_raw |>
  mutate(
    RACE_ETHNICITY = case_when(
      (RACE_mod == "Black/African American" & HISPAN == "Not Hispanic") ~ "Black, Non-Hispanic",
      (RACE_mod == "White" & HISPAN == "Not Hispanic") ~ "White, Non-Hispanic",
      (RACE_mod == "Other" & HISPAN == "Not Hispanic") ~ "Other, Non-Hispanic",
      (HISPAN %in% c("Mexican", "Puerto Rican", "Cuban", "Other")) ~ "Hispanic",
      .default = NA_character_
    )
  )

# Check if `RACE_ETHNICITY` correctly codes `RACE_mod` and `HISPAN` by verifying their unique combinations
acs5_2021_raw |> distinct(RACE_ETHNICITY, RACE_mod, HISPAN)
```

Income subgroup is created at two levels: - Less than \$50,000 - \$50,000 or More

```{r}
#| label: create-subgroup-income

# Create `INCOME` subgroup using `HHINCOME`
acs5_2021_raw <- acs5_2021_raw |>
  mutate(
    INCOME = case_when(
      HHINCOME < 50000 ~ "Less than $50,000",
      HHINCOME >= 50000 ~ "$50,000 or More",
      .default = NA_character_)
    )

# Verify that `INCOME` is coded correctly
stopifnot(all(acs5_2021_raw$INCOME[acs5_2021_raw$HHINCOME < 50000] == "Less than $50,000"))

stopifnot(all(acs5_2021_raw$INCOME[acs5_2021_raw$HHINCOME >= 50000] == "$50,000 or More"))

```

### Computer and Internet Use Variables

-   For measuring digital access, a composite variable `DIGITAL_ACCESS` is created using `CIHISPEED`, `CILAPTOP`, and `CITABLET` IPUMS variables.

- `CILAPTOP` indicates whether the respondent or any member of their household owned or used a desktop, laptop, netbook, or notebook computer. 

- `CITABLET` indicates whether the respondent or any member of their household owned or used a tablet or other portable wireless computer.

-   `CINETHH` is derived from Question 9 in the ACS listed below:

```         
  9. At this house, apartment, or mobile home - do you or any member of this 
      household have access to the internet?
    [ ] Yes, by paying a cell phone company or Internet service provider
    [ ] Yes, without paying a cell phone company of Internet service provider -> 
    SKIP to question 11
    [ ] No access to the Internet at this house, apartment, or mobile home -> 
    SKIP to question 11
```

-   `CIHISPEED` is derived from Question 10, part (b) in the ACS listed below:

```         
  10. Do you or any member of this household have access to the Internet using a -

  b) broadband (high speed) Internet service such as cable, fiber optic, or DSL 
      service installed in this household?
      [ ]Yes
      [ ]No
```

We first investigate the unique values and labels that exist for the computer and internet use variables in the IPUMS data.

```{r}
#| label: data-exploration

# Find unique values and corresponding label values in the data

# In this data, we only observe values "1" and "2" corresponding to labels
# "Yes" and "No" respectively for `CITABLET`
unique(acs5_2021_raw$CITABLET)


# In this data, we only observe values "1" and "2" corresponding to labels
# "Yes" and "No" respectively for `CILAPTOP`
unique(acs5_2021_raw$CILAPTOP)


# In this data, we only observe values "0", "10" , and "20" corresponding to labels
# "N/A (GQ)", "Yes (Cable modem, fiber optic or DSL service)", and "No" 
# respectively for `CIHISPEED`

#### NOTE: It seems like "N/A (GQ)" value exists in the data even after group quarters 
# are removed from the data. Casual inspection of data frame suggests that even 
# if a household is classified as a housing unit, it might still have value "N/A (GQ)"
# in the `CIHISPEED` variable.
unique(acs5_2021_raw$CIHISPEED)


# In this data, we observe values "1", "2", and "3" corresponding to labels 
# 'Yes, with a subscription to an Internet Service', 'Yes, without a subscription 
# to an Internet Service' and 'No Internet access at this house, apartment, or 
# mobile home' for `CINETHH`
unique(acs5_2021_raw$CINETHH)
```

In the data, it seems that `CIHISPEED` has N/A(GQ) values present. This needs to be investigated because group quarters were filtered out from the data so it is not clear why the `CIHISPEED` variable would have `N/A(GQ)` values. Investigating based on [this](https://forum.ipums.org/t/cihispeed-group-quarters/3453) discussion on IPUMS forum.

> We consider the `CINETHH` variable to find the universe of observations for households with digital access. This variable indicates whether any member of a household has access to the internet (by either paying or without paying a cellphone company) or nobody in the household has access to the internet.

Since, `CINETHH` is the universe of observations, first, let's observe the relationship between `CINETHH` and `CIHISPEED` in relation to the `CIHISPEED` variable taking the value `0` corresponding to label `N/A(GQ)`.

```{r}
#| label: investigate-data-issue-1

# Subset dataframe so that only `CIHISPEED` = 0 values are retained and check
# the values that exist for `CINETHH`

print(paste0("When `CIHISPEED` equals `0` i.e. 'N/A (GQ)' then `CINETHH` takes up ", 
              "following values:"))

acs5_2021_raw |>
  filter(CIHISPEED==0) |>
  distinct(CIHISPEED, CINETHH)
```


```{r}
#| label: investigate-data-issue-2

# Subset dataframe so that `CIHISPEED` = 0 values are removed and check
# the values that exist for `CINETHH`

print(paste0("When `CIHISPEED` does not equal `0` i.e. 'N/A (GQ)' then `CINETHH` ", 
              "takes up following values:"))
acs5_2021_raw |>
  filter(CIHISPEED!=0) |>
  distinct(CIHISPEED, CINETHH)
```

```{r}
# Assert that when `CIHISPEED` == 0 then there aren't any instances where `CINETHH` is not equal to
# either 3 or 2
assertthat::assert_that(!any(
                             acs5_2021_raw$CIHISPEED==0 & 
                             !(acs5_2021_raw$CINETHH %in% c(3, 2))  
                             ))

```

```{r}
# Assert that when `CIHISPEED` != 0 then there aren't any instances where `CINETHH` is not equal to 1
assertthat::assert_that(!any(
                             acs5_2021_raw$CIHISPEED!=0 & 
                             !(acs5_2021_raw$CINETHH %in% 1)  
                             ))

```

The above results imply that `CIHISPEED` takes on 'N/A(GQ)' value when `CINETHH` indicates either 'No Internet access at this house, apartment, or mobile home' or 'Yes, without a subscription to an Internet Service'.

It is reasonable to assume based on the data values in the IPUMS extract that whenever a household skipped to question 11 while answering question 9 referenced earlier (i.e. answered access to internet without subscription or no subscription for question 9), the corresponding value assigned to `CIHISPEED` was 'N/A(GQ)' as for these households the question of having access to paid high speed broadband was inapplicable.

This finding tracks with the [IPUMS forum discussion](https://forum.ipums.org/t/cihispeed-group-quarters/3453) indicating that a household could have 'N/A(GQ)' values for reasons other than being categorized as a group quarter.

In light of this, our assumption stands that the universe of households to answer questions regarding digital access comes from the data encapsulated by the `CINETHH` variable. This will feed into the denominator to compute share of digital access in a geography. The target households are those which answered Question 9 in the ACS. We will remove any households that have `CINETHH` equals `0` i.e. `N/A(GQ)` as they will not be a part of our target universe of households. 

```{r}
#| label: universe-for-digital-access

# Remove `0` values labelled `N/A (GQ)` for `CINETHH` as they do not represent households of interest

# Check if any `0` values exist in `CINETHH`
if ( any(acs5_2021_raw$CINETHH == 0) ) {
  
  acs5_2021_raw <- acs5_2021_raw |> 
                                 filter(CINETHH!=0)
} else {
  print("Variable `CINETHH` represents households of interest.")
}

```

### Digital Access

Create `DIGITAL_ACCESS`as a composite binary variable that takes on the value `1` when a household has access to high speed internet and either a tablet or laptop computer or both.

For computing `DIGITAL_ACCESS`, we consider that access relies on whether `CIHISPEED` indicates household has access to high speed internet or not. If `CIHISPEED` has value `N/A(GQ)` after filtering for group quarters, we assume that the corresponding `DIGITAL_ACCESS` for those households would be `N/A` as they did not answer question 10 and instead skipped to Question 11.

```{r}
#| label: create-composite-digital-access

# Create `DIGITAL_ACCESS` composite binary variable using `CIHISPEED`, `CILAPTOP`, 
# and `CITABLET`

acs5_2021_raw <- acs5_2021_raw |>
  mutate(
    DIGITAL_ACCESS = case_when(
      ((CILAPTOP == 1 | CITABLET == 1) & CIHISPEED == 10) ~ 1,
      CIHISPEED == 20 ~ 0,
      .default = NA_integer_)
    )

```


## Merge Crosswalk {#sec-merge-crosswalk}

The 5-yr 2017-21 ACS data from IPUMS needs to be merged with PUMA to county and PUMA to place geocodes to get county and place boundaries.

::: panel-tabset
### PUMA to County

Since, the data IPUMS data is pre-2022, a crosswalk from 2012 PUMA to 2014 county is used. This crosswalk is derived from [Geocorr](https://mcdc.missouri.edu/applications/geocorr2022.html) as documented in ["Generate Puma to County Crosswalk"](geographic-crosswalks/generate_puma_county_crosswalks.qmd).

```{r}
#| label: crosswalk-puma-county-1

# Read the relevant crosswalk file
crosswalk_puma_county <- read_csv((here::here("geographic-crosswalks", 
                                              "data", 
                                              "crosswalk_puma_to_county.csv"))) |>
  # filter the crosswalk for the data period 2017-2021
  filter(crosswalk_period == "pre-2022") |>
  rename(STATE = statefip,
         COUNTY = county,
         PUMA = puma) |>
  # drop Puerto Rico from the crosswalk
  filter(STATE != "72")
```

The `crosswalk_puma_to_county.csv` crosswalk has a variable called `afact` (for more information see ["Generate Puma to County Crosswalk"](geographic-crosswalks/generate_puma_county_crosswalks.qmd) notebook), which gives the allocation factor for the PUMA area that falls within a given county area. Another variable of interest is `sum_products` which is a geographic allocation quality variable derived from the Geocorr data as documented in ["Generate Puma to County Crosswalk"](geographic-crosswalks/generate_puma_county_crosswalks.qmd).

If a county in the IPUMS data is unidentifiable, the corresponding value for county will be `000` ([see](https://usa.ipums.org/usa-action/variables/COUNTYFIP#codes_section)). 
  - We rely on the crosswalk information to substitute for counties that have `000` value in IPUMS. 
  - For these, cases we also adjust the household weight `HHWT` by multiplying `HHWT` with `afact` to
  account for the county geography a household in a PUMA can be associated with. 
  - Lastly, for the unidentifiable counties, the geographic allocation variable `sum_products` from the
  crosswalk will be leveraged. However, for identifiable counties from the IPUMS data, we will assign a
  value of `1` to `sum_products` as the PUMAs are mapped to their associated counties. 

`crosswalk_puma_county` contains the relevant counties that we need in our final data. These will be merged with the clean 5-yr 2017-21 ACS data to map the PUMA geocodes with their corresponding county geocodes. The weight of each household will be adjusted by the proportion of the PUMA area that falls into a given County.

Depends on which geographies are available in the raw IPUMS data.

```{r}
#| label: crosswalk-puma-county-2

# Merge crosswalk PUMA to county with the IPUMS data
acs5_2021_county <- acs5_2021_raw |>
  right_join(
             crosswalk_puma_county,
             by = c("STATE", "PUMA"),
             relationship = "many-to-many"
  ) |>
  # Use county codes from crosswalk if they're not present in the IPUMS data
  mutate(
    COUNTY = if_else(COUNTY.x != "000", COUNTY.x, COUNTY.y),
    HHWT = if_else(COUNTY.x != "000", HHWT, HHWT * afact),
    sum_products = if_else(COUNTY.x != "000", 1, sum_products) 
  ) |>
  select(-c(COUNTY.x, COUNTY.y)) |>
  mutate(
          COUNTY = str_pad(COUNTY, width = 3, pad = "0", side = "left"
  )
) 

```

### PUMA to Place

Since, the data IPUMS data is pre-2022, a crosswalk from 2012 PUMA to 2014 place is used. This crosswalk is derived from [Geocorr](https://mcdc.missouri.edu/applications/geocorr2022.html) as documented in ["Generate Puma to County Crosswalk"](geographic-crosswalks/generate_puma_county_crosswalks.qmd).

```{r}
#| label: crosswalk-puma-place-1

# Read the relevant crosswalk file
crosswalk_puma_place <- read_csv((
                                  here::here("geographic-crosswalks", 
                                              "data", 
                                              "crosswalk_puma_to_place.csv")
  )) |>
  # filter the crosswalk for the data period 2017-2021
  filter(crosswalk_period == "pre-2022") |>
  rename(
          STATE = statefip,
          PUMA = puma
  ) 
```

The `crosswalk_puma_to_place.csv` crosswalk has a variable called `afact` (for more information see ["Generate Puma to Place Crosswalk"](geographic-crosswalks/generate_puma_place_crosswalks.qmd) notebook), which gives the allocation factor for the PUMA area that falls within a given place area. Another variable of interest is `sum_products` which is a geographic allocation quality variable derived from the Geocorr data as documented in ["Generate Puma to County Crosswalk"](geographic-crosswalks/generate_puma_county_crosswalks.qmd). 

IPUMS data doesn't have place geography, so we rely on the crosswalk. The weight of each household will be adjusted by the proportion of the PUMA area that falls into a given place. This is done by multiplying `HHWT` with `afact`. For places, we do not make changes to the `sum_products` variable and rely on the crosswalk for this information.

`crosswalk_puma_place` contains the relevant places that we need in our final data. These will be merged with the clean 5-yr 2017-21 ACS data to map the PUMA geocodes with their corresponding place geocodes. The weight of each household will be adjusted by the proportion of the PUMA area that falls into a given Place.

```{r}
#| label: crosswalk-puma-place-2

# Merge crosswalk PUMA to county with the IPUMS data
acs5_2021_place <- acs5_2021_raw |>
  right_join(
             crosswalk_puma_place,
             by = c("STATE", "PUMA"),
             relationship = "many-to-many"
  ) |>
  # Use county codes from crosswalk if they're not present in the IPUMS data
  mutate(
    HHWT = HHWT * afact,
  ) 

```
:::

Filter out observations where household weight `HHWT` is N/A or zero as these will not be counted in the metric calculation because they do not contribute to the universe of households for this metric.

```{r}
#| label: clean-up-crosswalked-county

# Remove observations where HHWT is N/A
if ( sum(is.na(acs5_2021_county$HHWT)) > 0){
  
  acs5_2021_county <- acs5_2021_county |> 
                                    drop_na(HHWT)

} else 
  # Remove observations where HHWT is zero
  if ( sum(acs5_2021_county$HHWT == 0) > 0 ) {
  
  acs5_2021_county <- acs5_2021_county |> 
                                      filter(HHWT > 0)
} else {

  print("Household weight, HHWT, doesn't have any N/A or 0 values for counties.")
}
```


```{r}
#| label: clean-up-crosswalked-place

# Remove observations where HHWT is N/A
if ( sum(is.na(acs5_2021_place$HHWT)) > 0){
  
  acs5_2021_place <- acs5_2021_place |> 
                                    drop_na(HHWT)

} else 
  # Remove observations where HHWT is zero
  if ( sum(acs5_2021_place$HHWT == 0) > 0 ) {
  
  acs5_2021_place <- acs5_2021_place |> 
                                      filter(HHWT > 0)
} else {

  print("Household weight, HHWT, doesn't have any N/A or 0 values for places.")
}
```

## Create Metric {#sec-create-metric}

We need to create the digital access metric as a share of households having access to either a tablet or laptop and a high speed internet connection for a given county/place. However, in an IPUMS sample a household may be representative of many households which is gauged through the `HHWT` variable. So, to find the share of households with digital access, a weighted measure is needed. 

This weighted measure, `HHWTD_DIGITAL_ACCESS`, will be created using the composite `DIGITAL_ACCESS` variable coded earlier.

```{r}
#| label: weighted-digital-access

# Create weighted digital access variable

acs5_2021_place <- acs5_2021_place |>
mutate(HHWTD_DIGITAL_ACCESS = if_else(DIGITAL_ACCESS == 1, HHWT, 0))

acs5_2021_county <- acs5_2021_county |>
mutate(HHWTD_DIGITAL_ACCESS = if_else(DIGITAL_ACCESS == 1, HHWT, 0))

```

For quality measures, compute effective sample size count for each county/place which is the unweighted sum of households present in the data for each geography. The effective sample will indicate the actual number of survey records that will factor into metric calculation as we do not want to include geographies with less than 30 records for quality purposes.

```{r}
#| label: create-effective-sample-county

# Create effective sample count variable for county
acs5_2021_county <- acs5_2021_county |>
    group_by(YEAR, STATE, COUNTY) |>
    mutate(
      effective_sample_count = n()
    ) |>
    ungroup()

# Summarize effective sample count information for county
acs5_2021_county |>
  group_by(YEAR, STATE, COUNTY) |>
  summarise(
    effective_sample_count = first(effective_sample_count)
  ) |>
  ungroup() |>
  summarise(
    total_counties = n(),
    effective_30_sample_counties = sum(effective_sample_count > 30)
  )
```

```{r}
#| label: create-effective-sample-place

# Create effective sample count variable for place
acs5_2021_place <- acs5_2021_place |>
    group_by(YEAR, STATE, place) |>
    mutate(
      effective_sample_count = n()
    ) |>
    ungroup()

# Summarize effective sample count information for place
acs5_2021_place |>
  group_by(YEAR, STATE, place) |>
  summarise(
    effective_sample_count = first(effective_sample_count)
  ) |>
  ungroup() |>
  summarise(
    total_places = n(),
    effective_30_sample_places = sum(effective_sample_count > 30)
  )

```

Using the weighted digital access measure, we will compute the county and place level metric. The digital access metric will represent the number of households that have digital access divided by the total number of households for a given geography at the county/place level. The numerator represents the households which have access to high speed internet and a tablet/laptop computer. The denominator represents all the households that do (either with subscription or without) and do not have access to the internet.

### County

```{r}
#| label: digital-access-county

# Compute share of households with digital access in a given county

share_dig_acc_county <- 
  acs5_2021_county |>
  # Filter counties with less than 30 samples
  filter(effective_sample_count >= 30) |>
  select("YEAR", "STATE", "COUNTY", "HHWTD_DIGITAL_ACCESS", "HHWT",
          "effective_sample_count") |>
  group_by(YEAR, STATE, COUNTY) |>
  summarise(
    # Sum households with digital access, remove households assigned `NA`
    county_dig_acc = sum(HHWTD_DIGITAL_ACCESS, na.rm=TRUE),
    # Total households include all households that do/do not have access
    total = sum(HHWT),
    effective_sample_count = first(effective_sample_count),
    .groups = 'drop'
  ) |>
  # Calculate share of households with digital access
  mutate(
    share_digital_access = county_dig_acc/total
  ) |>
  select(YEAR, STATE, COUNTY, share_digital_access, effective_sample_count) |>
  janitor::clean_names()

```

### County Subgroups: Race-Ethnicity & Income

```{r}
#| label: function-share-digital-access

# Compute share of households with digital access based on geography and subgroup
# Geography can take values "COUNTY" or "place"
# Subgroup can take values "RACE_ETHNICITY" or "INCOME"

compute_share_dig_acc_subgroup <- function(data, geo, subgroup_vars) {
  
  data <- data |>
  select(c("YEAR", "STATE", all_of(geo), "HHWTD_DIGITAL_ACCESS", "HHWT", 
            all_of(subgroup_vars))) |>
  # Group data by geography and subgroup
  group_by(across(c("YEAR", "STATE", all_of(geo), all_of(subgroup_vars)))) |>
  summarise(
    # Sum households with digital access, remove households assigned `NA`
    subgroup_dig_acc = sum(HHWTD_DIGITAL_ACCESS, na.rm=TRUE),
    # Total households include all households that do/do not have access
    total_subgroup = sum(HHWT),
    # Compute subgroup effective sample size,
    effective_sample_count = n(),
    .groups = 'drop'
  ) |>
  # Calculate share of households with digital access
  mutate(
    share_digital_access = subgroup_dig_acc/total_subgroup
  ) |> 
  # Mark digital access as N/A for subgroups with sample size < 30 
  mutate(
   share_digital_access = if_else(effective_sample_count < 30, NA_real_, 
                                                            share_digital_access)
  ) |>
  select(c("YEAR", "STATE", geo, subgroup_vars,"effective_sample_count", 
    "share_digital_access")) |>
  janitor::clean_names()

  return (data)
}

```

```{r}
#| label: digital-access-county-subgroups

# Compute share of households with digital access in a given county by race-ethnicity
share_dig_acc_county_race_ethnicity <- 
    compute_share_dig_acc_subgroup(acs5_2021_county, "COUNTY", "RACE_ETHNICITY")


# Compute share of households with digital access in a given county by income
share_dig_acc_county_income <- 
  compute_share_dig_acc_subgroup(acs5_2021_county, "COUNTY", "INCOME")

```

### Place

```{r}
#| label: digital-access-place

# Compute share of households with digital access in a given place
share_dig_acc_place <- 
  acs5_2021_place |>
  # Filter places with less than 30 samples
  filter(effective_sample_count >= 30) |>
  select("YEAR", "STATE", "place", "HHWTD_DIGITAL_ACCESS", "HHWT",
         "effective_sample_count") |>
  group_by(YEAR, STATE, place) |> 
  summarise(
    # Sum households with digital access, remove households assigned `NA`
    place_dig_acc = sum(HHWTD_DIGITAL_ACCESS, na.rm=TRUE),
    # Total households include all households that do/do not have access
    total = sum(HHWT),
    effective_sample_count = first(effective_sample_count),
    .groups = 'drop'
  ) |>
  # Calculate share of households with digital access
  mutate(
    share_digital_access = place_dig_acc/total
  ) |>
  select(YEAR, STATE, place, share_digital_access, effective_sample_count) |>
  janitor::clean_names()

```

### Place Subgroups: Race-Ethnicity & Income

```{r}
#| label: digital-access-place-subgroups

# Compute share of households with digital access in a given place by race-ethnicity
share_dig_acc_place_race_ethnicity <- 
    compute_share_dig_acc_subgroup(acs5_2021_place, "place", "RACE_ETHNICITY")

  
# Compute share of households with digital access in a given place by income
share_dig_acc_place_income <- 
    compute_share_dig_acc_subgroup(acs5_2021_place, "place", "INCOME")

```

## Explore Metric {#sec-evaluate-metric}

Let's assess the digital access metric. As the share of digital access metric is a proportion, it's value should fall between 0 and 1 (inclusive) and we need to verify this.

```{r}
#| label: metric-range-checks

# Check the range of digital access metric is between 0 and 1

all_df <- list(share_dig_acc_county, share_dig_acc_county_income, 
                share_dig_acc_county_race_ethnicity, share_dig_acc_place,
                share_dig_acc_place_income, share_dig_acc_place_race_ethnicity)

# Find min and max values for digital access metric
max_vals <- sapply(all_df, function(x) max(x$share_digital_access, na.rm=TRUE))
min_vals <- sapply(all_df, function(x) min(x$share_digital_access, na.rm=TRUE))

# All minimum metric values should be less than or equal to 1 and greater than or
# equal to 0
min_max_check <- data.frame(
    df_name = c('share_dig_acc_county', 'share_dig_acc_county_income', 
                'share_dig_acc_county_race_ethnicity', 'share_dig_acc_place',
                'share_dig_acc_place_income', 'share_dig_acc_place_race_ethnicity'),
    min_greater_than_equal_zero = sapply(min_vals, function(x) x >= 0),
    max_less_than_equal_one = sapply(max_vals, function(x) x <= 1)

)

print(min_max_check)

rm(all_df)
```

The digital access metric should have a value of `NA` when effective sample size is less than 30. Let's verify this.

```{r}
#| label: metric-range-checks

# Check that if effective sample size is less than 30, then share of digital access only has NA values 
stopifnot( !any( 
                (share_dig_acc_county$effective_sample_count < 30) &        
                 !is.na(share_dig_acc_county$share_digital_access) 
          ))

stopifnot( !any( 
                (share_dig_acc_county_income$effective_sample_count < 30) &        
                 !is.na(share_dig_acc_county_income$share_digital_access) 
          ))

stopifnot( !any( 
                (share_dig_acc_county_race_ethnicity$effective_sample_count < 30) &        
                 !is.na(share_dig_acc_county_race_ethnicity$share_digital_access) 
          ))

stopifnot( !any( 
                (share_dig_acc_place$effective_sample_count < 30) &        
                 !is.na(share_dig_acc_place$share_digital_access) 
          ))

stopifnot( !any( 
                (share_dig_acc_place_race_ethnicity$effective_sample_count < 30) &        
                 !is.na(share_dig_acc_place_race_ethnicity$share_digital_access) 
          ))

stopifnot( !any( 
                (share_dig_acc_place_income$effective_sample_count < 30) &        
                 !is.na(share_dig_acc_place_income$share_digital_access) 
          ))

```

To get a better sense of the distribution of the digital access metric, we visualize it for both county and place.

```{r}

#| label: metric-visualization-function

metric_visualization_subgroup <- function(data, subgroup, subtitle) {
  
  data <- data |> drop_na()

  data |>
    ggplot(aes(x = share_digital_access)) +
    geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 0.02) +
    facet_wrap(.~ data[[subgroup]]) +
    labs(
      title = paste0("Share of Digital Access by ", 
                      str_to_title(gsub("_", " and ", subgroup))),
      subtitle = subtitle,
      y = "Count",
      x = "Share of Digital Access"
    )
}

```

::: panel-tabset
### Visualizing Digital Access for County by Race and Ethnicity

```{r}

metric_visualization_subgroup(
  share_dig_acc_county_race_ethnicity, 
  "race_ethnicity",
  "County")

quantile(share_dig_acc_county_race_ethnicity$share_digital_access, na.rm=TRUE)
skimr::skim(share_dig_acc_county_race_ethnicity)

```

### Visualizing Digital Access for County by Income

```{r}

metric_visualization_subgroup(
  share_dig_acc_county_income, 
  "income",
  "County")

quantile(share_dig_acc_county_income$share_digital_access, na.rm=TRUE)
skimr::skim(share_dig_acc_county_income)

```

### Visualizing Digital Access for Place by Race and Ethnicity

```{r}

metric_visualization_subgroup(
  share_dig_acc_place_race_ethnicity, 
  "race_ethnicity",
  "Place")

quantile(share_dig_acc_place_race_ethnicity$share_digital_access, na.rm=TRUE)
skimr::skim(share_dig_acc_place_race_ethnicity)

```

### Visualizing Digital Access for Place by Income

```{r}

metric_visualization_subgroup(
  share_dig_acc_place_income, 
  "income",
  "Place")

quantile(share_dig_acc_place_income$share_digital_access, na.rm=TRUE)
skimr::skim(share_dig_acc_place_income)

```
:::

## Metric Quality {#sec-metric-quality}

Determining the quality of the digital access metric is a two step process that considers an effective sample test and geographic allocation test.

-   Effective sample test entails that for the IPUMS micro data each geography must have a sample of at least 30 survey responses otherwise we report the metric as NA for that geography. This is useful because counties/places with an extremely small number of households sampled would have a poorer data quality.

-   Geographic allocation test leverages the project crosswalks (either from PUMA to county or PUMA to place for IPUMS data) which include a measure for quality based on the area of the IPUMS geography (PUMA) that falls within the target geography (county/place). This helps figure out how much of the data associated with a county/place actually came from that county/place and is measured by the `sum_products` variable in the crosswalks (for more information see ["Generate Puma to County Crosswalk"](geographic-crosswalks/generate_puma_county_crosswalks.qmd) notebook). 

Combining the above two guidelines for quality testing, the following measure of digital access quality is determined:

-   Data quality is Strong (`1`): When number of households in a geography is greater than or equal to 30 and 75% or more of the observations (estimated by `sum_products`) are from the county/place.

-   Data quality is Adequate (`2`): When number of households in a geography is greater than or equal to 30 but only 35% to 74% of the observations are from the county/place.

-   Data quality is Weak (`3`): When number of households in a geography is greater than or equal to 30 but less than 35% of the observations are from the county/place.

-   Data quality is NA: When number of households in a geography is less than 30.


Earlier, the `sum_products` variable was modified for county data. Let's check whether each unique county/place has a singular `sum_products` value associated to make sure we did not introduce any errors. This check will also help extract the `sum_products` associated with each county and place so that we can use these values for computing the quality metric.

```{r}
#| label: check-sum-products-county

# Check whether each unique combination of state and county has the same `sum_products`
# value associated

# For county

# In this data, each county is observed to have one `sum_products` value which 
# checks out with the logic of crosswalks
quality_county <- acs5_2021_county |>
      select("YEAR", "STATE", "COUNTY", "sum_products") |>
      group_by(YEAR, STATE, COUNTY) |>
      summarise(
          distinct_sum_products = n_distinct(sum_products),
          sum_products = list(unique((sum_products)))
        ) |>
      ungroup() |>
      janitor::clean_names()

print("Are there any counties with multiple `sum_products` values?")
any(quality_county$distinct_sum_products > 1)
```

```{r}
#| label: check-sum-products-place

# For place

# In this data, each place is observed to have one `sum_products` value which 
# checks out with the logic of crosswalks
quality_place <- acs5_2021_place |>
      select("YEAR", "STATE", "place", "sum_products") |>
      group_by(YEAR, STATE, place) |>
      summarise(
          distinct_sum_products = n_distinct(sum_products),
          sum_products = list(unique((sum_products)))
        ) |>
      ungroup() |>
      janitor::clean_names()

print("Are there any places with multiple `sum_products` values?")
any(quality_place$distinct_sum_products > 1)

```

Putting together the `sum_products` and effective sample size values together will help create the digital access quality variable.

```{r}
#| label: function-data-quality-metric

create_quality_metric <- function(metric_df, quality_df, geo) {

    # Create data quality metric
    data <- metric_df |>
              right_join(quality_df,
                          by = c("year", "state", geo)) |>
              select(-c("distinct_sum_products")) |>
              mutate(quality_digital_access = case_when(
              (effective_sample_count < 30) ~ NA_integer_,
              (effective_sample_count >=30 & sum_products >= 0.75) ~ 1,
              (effective_sample_count >= 30 & sum_products >= 0.35) ~ 2,
              (effective_sample_count >= 30 & sum_products < 0.35) ~ 3,
              .default = NA_integer_
              ))
    
    return (data)
}

```


```{r}
#| label: create-data-quality-variable

# Add data quality variable to digital access metric 

# For counties
share_dig_acc_county <- create_quality_metric(share_dig_acc_county, 
                                              quality_county, "county")

share_dig_acc_county_income <- create_quality_metric(share_dig_acc_county_income, 
                                                      quality_county, "county")

share_dig_acc_county_race_ethnicity <- create_quality_metric(share_dig_acc_county_race_ethnicity, 
                                                      quality_county, "county")

# For places
share_dig_acc_place <- create_quality_metric(share_dig_acc_place, 
                                              quality_place, "place")

share_dig_acc_place_income <- create_quality_metric(share_dig_acc_place_income, 
                                              quality_place, "place")

share_dig_acc_place_race_ethnicity <- create_quality_metric(share_dig_acc_place_race_ethnicity, 
                                              quality_place, "place")

```

## Evaluate Metric {#evaluate-metric}

Check there are 3143 unique counties and 485 unique places in the pre-2022 crosswalks. (See the [Wiki](https://github.com/UI-Research/mobility-from-poverty/wiki/5_Geographies-&-Crosswalks) for more information )

```{r}

# Unique counties in PUMA to county crosswalk
n_distinct(crosswalk_puma_county[c("STATE", "COUNTY")])

# We observe 3143 unique counties in the crosswalk
counties_pre_2022 <- crosswalk_puma_county |>
                janitor::clean_names() |>
                distinct(state, county) |>
                arrange(state, county)

# Unique counties in PUMA to place crosswalk
n_distinct(crosswalk_puma_place[c("STATE", "place")])

# We observe 485 unique places in the crosswalk
places_pre_2022 <- crosswalk_puma_place |>
                janitor::clean_names() |>
                distinct(state, place) |>
                arrange(state, place)
```

Check whether counties present during digital access metric calculation for county and place are the same ones present in the crosswalks as calculated in `counties_pre_2022` and `places_pre_2022`. This is done to verify that our final contains all the required geographies.

```{r}
#| label: function-geography-equivalence

#' This function asserts whether the unique counties/places present in the digital metric calculations are the same ones as the unique counties/places from crosswalk data frames (`counties_pre_2022`, `places_pre_2022`)
check_geography_equivalence <- function(crosswalk, metric, geo) {
  return (assertthat::assert_that(
      all.equal(
            crosswalk,
            metric |>
                distinct(across(c("state", geo))) |>
                arrange(across(c("state", geo)))
    )
 ))
}

```


```{r}
#| label: check-missing-counties

# Check all 3143 counties and 385 counties are present in our respective metric data calculations 

stopifnot(check_geography_equivalence(counties_pre_2022, share_dig_acc_county, "county"))

stopifnot(check_geography_equivalence(counties_pre_2022, share_dig_acc_county_race_ethnicity
                            , "county"))

stopifnot(check_geography_equivalence(counties_pre_2022, share_dig_acc_county_income
                            , "county"))

stopifnot(check_geography_equivalence(places_pre_2022, share_dig_acc_place, "place"))

stopifnot(check_geography_equivalence(places_pre_2022, share_dig_acc_place_race_ethnicity
                            , "place"))

stopifnot(check_geography_equivalence(places_pre_2022, share_dig_acc_place_income
                            , "place"))
```

The above results suggest that all of the unique counties/places from the crosswalks are present in the digital access metric calculation.

Check whether required number of observations exist for each subgroup associated with county and place digital access metric.


```{r}
# For county race-ethnicity subgroup there should be 3143*4 observations
assertthat::are_equal((3143 * 4), nrow(share_dig_acc_county_race_ethnicity))
# We observe missingness for some counties for the `Black, Non-Hispanic` subgroup type
share_dig_acc_county_race_ethnicity |> 
      group_by(race_ethnicity) |> 
      summarise(n = n())

# For county income subgroup there should be 3143*2 observations
assertthat::are_equal((3143 * 2), nrow(share_dig_acc_county_income))

share_dig_acc_county_income |> 
      group_by(income) |> 
      summarise(n = n())

# For place race-ethnicity subgroup there should be 485*4 observations
assertthat::are_equal((485 * 4), nrow(share_dig_acc_place_race_ethnicity))

share_dig_acc_place_race_ethnicity |> 
      group_by(race_ethnicity) |> 
      summarise(n = n())

# For place income subgroup there should be 485*2 observations
assertthat::are_equal((485 * 2), nrow(share_dig_acc_place_income))

share_dig_acc_place_income |> 
      group_by(income) |> 
      summarise(n = n())
```

Expected number of observations are present in the data for county income subgroup, place race-ethnicity subgroup, and place income subgroup. However, the above results suggest that there is missingness in digital access metric observation for `Black, Non-Hispanic` race-ethnicity subgroup data for some counties. This missing data is likely the result of subgroup samples not being present in the data for some counties when we drill down to the subgroup level from the overall county level.  

```{r}

# Find counties missing in the race-ethnicity subgroup data set

missing_counties <- anti_join(counties_pre_2022, 
                              share_dig_acc_county_race_ethnicity |>
                                filter(race_ethnicity == "Black, Non-Hispanic"), 
                              by = c("state", "county"))

```

Let's check whether the missing counties have any households with `RACE_ETHNICITY` subgroup "Black, Non-Hispanic" present in the county data before we calculated share of digital access at subgroup level.

```{r}

# Check whether any rows exist in the data for "Black, Non-Hispanic" households for the missing counties 
stopifnot( nrow( acs5_2021_county |> 
                    rename(state = STATE, county = COUNTY) |>
                    # Retain only missing counties in IPUMS county data
                    semi_join(missing_counties, by = c("state", "county")) |>
                    select(state, county, RACE_ETHNICITY) |>
                    # Filter for the relevant `RACE_ETHNICITY` subgroup
                    filter(RACE_ETHNICITY == "Black, Non-Hispanic") |>
                    # Count the subgroup samples for each county
                    group_by(state, county, RACE_ETHNICITY) |> summarize(n())
                ) == 0
          )

```

From the above test we can confirm that "Black, Non-Hispanic" subgroup does not exist for some counties which is why county race-ethnicity subgroup metric data is missing some values. 

So, we add missing counties back to the county race-ethnicity subgroup metric data with `share_digital_access` value as N/A.

```{r}

# Add rows corresponding to missing counties for the county `Black, Non-Hispanic` 
# race-ethnicity subgroup

# Create data with missing county data for the subgroup with N/A values for metric
missing_data <- data.frame(
                  year = 2021,
                  state = missing_counties$state,
                  county = missing_counties$county,
                  race_ethnicity = "Black, Non-Hispanic",
                  effective_sample_count = NA,
                  share_digital_access = NA_real_,
                  sum_products = NA,
                  quality_digital_access = NA_integer_
                )

# Add the missing data to applicable subgroup data set 
share_dig_acc_county_race_ethnicity <-
    rbind(share_dig_acc_county_race_ethnicity, missing_data)

# Check data is not missing anymore
assertthat::are_equal((3143 * 4), nrow(share_dig_acc_county_race_ethnicity))

share_dig_acc_county_race_ethnicity |> 
      group_by(race_ethnicity) |> 
      summarise(n = n())

stopifnot(check_geography_equivalence(counties_pre_2022, 
                            share_dig_acc_county_race_ethnicity, 
                            "county"))
```

## Final Data {#sec-final-data}

The final output files will include digital access metric calculated for county and place at the overall and subgroup level.

The subgroups level data files should include a row indicating the metric value for the overall population. We need to add "All" subgroup to the race-ethnicity and income variables in the data. This data will be extracted from the overall final data and appended to the subgroup data.

```{r}
#| label: function-overall-subgroup-row

# Add row indicating `all` metric value corresponding to entire population for
# subgroup datasets
# In this function `subgroup` can take values "race_ethnicity" and "income"
# `overall_df` corresponds to data frame with the digital access metric for all 
# the counties and `subgroup_df` corresponds to the data frame  with the digital 
# access metric for county subgroups

create_all_subgroup <- function(overall_df, subgroup_df, subgroup) {
  
  # Add "All" as subgroup in the overall population metric data
  overall_df <- overall_df |>
                mutate(!!subgroup := "All")
  
  # Re-arrange metric columns based on subgroup data
  overall_df <- overall_df[, names(subgroup_df)]
  
  # Combine overall and subgroup data
  subgroup_df <- rbind(subgroup_df, overall_df)
  
  return (subgroup_df)
}

```


```{r}
#| label: add-overall-subgroup-row-county

# For county

# Add `All` metric value to subgroup data sets
share_dig_acc_county_race_ethnicity <- create_all_subgroup(
                                              share_dig_acc_county,
                                              share_dig_acc_county_race_ethnicity,
                                              "race_ethnicity")

share_dig_acc_county_income <- create_all_subgroup(
                                              share_dig_acc_county,
                                              share_dig_acc_county_income,
                                              "income")

# Check all counties are present in updated subgroups data
stopifnot(check_geography_equivalence(counties_pre_2022, 
                            share_dig_acc_county_race_ethnicity |> 
                                filter(race_ethnicity == "All"),
                            "county"))

stopifnot(check_geography_equivalence(counties_pre_2022, 
                            share_dig_acc_county_income |> 
                                filter(income == "All"),
                            "county"))
```


```{r}
#| label: add-overall-subgroup-row-place
# For place

# Add `All` metric value to subgroup data sets
share_dig_acc_place_race_ethnicity <- create_all_subgroup(
                                              share_dig_acc_place,
                                              share_dig_acc_place_race_ethnicity,
                                              "race_ethnicity")

share_dig_acc_place_income <- create_all_subgroup(
                                              share_dig_acc_place,
                                              share_dig_acc_place_income,
                                              "income")

# Check all places are present in updated subgroups data
stopifnot(check_geography_equivalence(places_pre_2022, 
                            share_dig_acc_place_race_ethnicity |> 
                                filter(race_ethnicity == "All"),
                            "place"))

stopifnot(check_geography_equivalence(places_pre_2022, 
                            share_dig_acc_place_income |> 
                                filter(income == "All"),
                            "place"))
```

The final data files need to be formatted according to UMF guidelines mentioned in the GitHub Wiki:

[2_Data Structure and Expectations](https://github.com/UI-Research/mobility-from-poverty/wiki/2_Data-Structure-and-Expectations%E2%80%AF) [9_Final File Output](https://github.com/UI-Research/mobility-from-poverty/wiki/9_Final-File-Output)

```{r}
#| label: function-final-data-export

#' @description Function to create the final data
#' 
#' @param `subgroups` is a indicator variable for the presence of subgroup in the final data
#' @param `subgroup_var` is a character variable for the name of the subgroup in the data 
#'  and can take values "race_ethnicity" and "income", defaults to NA
#' @param `geo` indicates whether data is for "county" or "place"
#' 
#' @return Data frame with the final data formatted

create_final_data <- function(data, subgroups, subgroup_var = NA, geo) {

    if (!subgroups) {
        
      data <- data |> 
                # Order the data
                arrange(year, state, geo) |>
                # Rename variables
                rename(share_digital_access_quality = quality_digital_access) |>
                select(year, state, geo, share_digital_access, share_digital_access_quality)
      
      }
      
    else {

      data <- data |> 
                # Order the data
                arrange(year, state, geo, subgroup_var) |>
                # Rename variables
                rename(
                        share_digital_access_quality = quality_digital_access,
                        subgroup = {{subgroup_var}}
                ) |>
                # Create subgroup_type variable indicating overall & subrgoup metric
                mutate( subgroup_type = 
                          case_when(
                                    (subgroup == "All") ~ "all",
                                    TRUE ~ as.character({{subgroup_var}}) )
                ) |>
                  select(year, state, geo, subgroup_type, subgroup, 
                          share_digital_access, share_digital_access_quality)
    }

    return (data)
}

```


```{r}
#| label: generate-final-data

# For county
final_share_dig_acc_county <- create_final_data(share_dig_acc_county, FALSE, geo = "county")

final_share_dig_acc_county_race_ethnicity <- create_final_data(share_dig_acc_county_race_ethnicity, 
                                                                      TRUE, "race_ethnicity", "county")

final_share_dig_acc_county_income <- create_final_data(share_dig_acc_county_income, 
                                                              TRUE, "income", "county")

# For place
final_share_dig_acc_place <- create_final_data(share_dig_acc_place, FALSE, geo = "place")

final_share_dig_acc_place_race_ethnicity <- create_final_data(share_dig_acc_place_race_ethnicity,
                                                                          TRUE, "race_ethnicity", "place")

final_share_dig_acc_place_income <- create_final_data(share_dig_acc_place_income, TRUE, "income", "place")

```

After generating the final data frames, we need to evaluate the outputs using the `evaluate_final_data` function per UMF [guidelines](https://github.com/UI-Research/mobility-from-poverty/wiki/8_Final-Data-Expectations-Form%E2%80%AF).

```{r, eval=FALSE}
#| label: final-data-evaluation-county

# For county data

evaluate_final_data(exp_form_path = "10a_final-evaluation/evaluation_form_digital_access_overall_county.csv",
    data = final_share_dig_acc_county, geography = "county",
    subgroups = FALSE, confidence_intervals = FALSE)

evaluate_final_data(exp_form_path = "10a_final-evaluation/evaluation_form_digital_access_race_ethnicity_county.csv",
    data = final_share_dig_acc_county_race_ethnicity, geography = "county",
    subgroups = TRUE, confidence_intervals = FALSE)

evaluate_final_data(exp_form_path = "10a_final-evaluation/evaluation_form_digital_access_income_county.csv",
    data = final_share_dig_acc_county_income, geography = "county",
    subgroups = TRUE, confidence_intervals = FALSE)


```


```{r, eval=FALSE}
#| label: final-data-evaluation-place

# For place data

evaluate_final_data(exp_form_path = "10a_final-evaluation/evaluation_form_digital_access_overall_place.csv",
    data = final_share_dig_acc_place, geography = "place",
    subgroups = FALSE, confidence_intervals = FALSE)

evaluate_final_data(exp_form_path = "10a_final-evaluation/evaluation_form_digital_access_race_ethnicity_place.csv",
    data = final_share_dig_acc_place_race_ethnicity, geography = "place",
    subgroups = TRUE, confidence_intervals = FALSE)

evaluate_final_data(exp_form_path = "10a_final-evaluation/evaluation_form_digital_access_income_place.csv",
    data = final_share_dig_acc_place_income, geography = "place",
    subgroups = TRUE, confidence_intervals = FALSE)


```


Lastly, after successful evaluation we save the final data files in folder `08_Education/data/final`.

```{r}
#| label: function-save-final-data

#' @description Function to save the final data files
#' 
#' @param `subgroups` is a indicator variable for the presence of subgroup in the final data
#' @param `subgroup_var` is a character variable for the name of the subgroup in the data 
#'  and can take values "race_ethnicity" and "income", defaults to NA
#' @param `geo` indicates whether data is for "county" or "place"
#' 

save_final_data <- function(data, subgroups, subgroup_var = NA, geo) {
  
  if (!subgroups) {
      
      file_name <- paste0("digital_access_", geo, "_all_longitudinal_", 
                            data$year[1], ".csv")
  } else {
  
      file_name <- paste0("digital_access_", geo, "_", subgroup_var, 
                            "_longitudinal_", data$year[1], ".csv")
    }
  
  # Define file path to save the final data file
  file_path <- here::here("08_education", "data", "final", file_name)
  
  # Save the csv file
  write.csv(data, file_path, row.names = FALSE)

}

```


```{r}

#| label: save-final-data

# For county
save_final_data(final_share_dig_acc_county, FALSE, geo = "county")

save_final_data(final_share_dig_acc_county_race_ethnicity, TRUE, "race_ethnicity", "county")

save_final_data(final_share_dig_acc_county_income, TRUE, "income", "county")

# For place
save_final_data(final_share_dig_acc_place, FALSE, geo = "place")

save_final_data(final_share_dig_acc_place_race_ethnicity, TRUE, "race_ethnicity", "place")

save_final_data(final_share_dig_acc_place_income, TRUE, "income", "place")

```




