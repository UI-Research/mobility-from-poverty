---
title: "College Readiness Predictor, County-level"
author: "JP Walsh"
date: today
format:
  html:
    toc: true
    toc_float: true
    embed-resources: true
    code-fold: show
execute: 
  warning: false
editor_options: 
  chunk_output_type: console
---

*Program for the creation of the College Readiness Upward Mobility Predictor at the county-level*

ACS Code: Initially written by Tina Chelidze and updated by JP Walsh 2022-2023.

Primary data derived from the IPUMS API. This metric is the share of 19- and 20-year-olds in a community who have a high school degree.

Based on processes developed by Paul Johnson and Kevin Werner in SAS.

-   [Housekeeping](#housekeeping)
-   [Read Data](#read-data)
-   [Clean Data](#clean-data)
-   [Merge Crosswalk](#merge-crosswalk)
-   [Setup Survey Design](#setup-survey-design)
-   [Create College Ready Metric](#create-college-ready-metric)
-   [Evaluate Results](#evaluate-results)
-   [Create standard errors](#create-standard-errors)
-   [Export](#export)


## Housekeeping

Read in packages for use. If you do not have an IPUMS API key you will need to make one via the [IPUMS website](https://www.ipums.org/).

```{r, results='hide'}
library(tidyverse)
library(Hmisc)
library(ipumsr)
library(reactable)
library(srvyr)
library(scales)

options(scipen = 999)


#set_ipums_api_key("Your KEY", save = TRUE)
purrr::walk(list.files(here::here("functions", "API")), 
    ~source(here::here("functions", "API", .x)))
```

## Read Data

Read in the ACS extracts using the extract_ipums function. Make sure to change the survey list to reflect what years you want to include in the data. Currently we are including two years of 5-year data (2018c and 2021c). 5-year 2022 data will be added pending its release.

*Note this download is slow and will take some time to finish. The notes on "Checking extract status" are a feature of the IPUMSR package and are to be expected*
```{r}
acs <- extract_ipums(
  extract_name = "umf_data_18_22",
  extract_description = "Microdata pull for College Readiness Metric Predictors. American Community Survey, years 2018, 2019 and 2022 (5-year).",
  survey = list("us2018c", "us2021c"))
```

Look at the distribution of ACS survey samples in the data. The number of different samples should align with the number of surveys selected in the extract ipums function.
```{r}
acs %>% 
  count(sample) %>% 
  ggplot(mapping = aes(x = sample, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Samples, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Samples",
       y = NULL)
```

Read in the PUMA to county crosswalk file. This file is created by the program generate_puma_county_crosswalks.rmd in the geographic-crosswalks folder. 
```{r}
puma_county_crosswalk <- read_csv(here::here("geographic-crosswalks", "data", "crosswalk_puma_to_county.csv"))
```

Crate a version of the crosswalk with just the county-level values of data quality variables for each crosswalk period.
```{r}
county_puma <- puma_county_crosswalk %>%
  group_by(crosswalk_period, statefip, county) %>% 
  summarise(geographic_allocation_quality = mean(geographic_allocation_quality)) %>% 
  ungroup()
```

## Clean Data

Missing data is reported in a variety of ways by IPUMS data. This step walks through the missing values in key variables and checks that we are dealing with them appropriately. 

Age: No missing values reported in variable description. Check the distribution to confirm there are no abnormalities: the distribution of age looks reasonable (no bunching or extreme outliers).

```{r}
acs %>% 
  ggplot(aes(x = age)) +
  geom_density(color = "blue", fill = alpha("blue", 0.3)) +
  theme_minimal() +
  ggtitle("Age Variable Results") +
  ylab("Density")
```

EDUCD: N/As reported as "1" in all modern surveys. N/As were "000" in the 1980 and 1950 decennial census surveys (not used here).
Variable codes explained [here]([https://usa.ipums.org/usa-action/variables/EDUC#codes_section) & see "Detailed codes" at bottom).
Vacancy is reported as "0". 

There is a significant share of records reported as "1" for the education variable. 

```{r}
acs %>% 
  mutate(educd = zap_labels(educd)) %>% 
  count(educd) %>% 
  ggplot(mapping = aes(x = factor(educd), y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Educd, All Records") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Educational Attainment",
       y = NULL)
```

Confirm the missing values from the value labels of the educd variable to ensure we are eliminating the correct values. "0", "1" and "999" are N/A or missing and should be turned into NA values that R recognizes. 

Note that there are no records with values of zero in the bar chart above which eliminates the need to deal with the "no schooling" option.
```{r}
head(ipums_val_labels(acs$educd), 50) %>% 
  reactable()
```

Turn the missing/"not in universe" value from the educd variable into NAs and remove the labels for the rest of the analysis. Rename to the more meaningful "education_detailed". 
```{r}
acs_educ <- acs %>%
  mutate(education_detailed = zap_labels(educd), 
         education_detailed = ifelse(education_detailed %in% c(1, 0, 999), NA_integer_,
                          education_detailed)
  )
```

Look at the distribution of education_detailed after adjustment for NAs. We can see that there are no longer records for "1" but we now see "NA".
```{r}
acs_educ %>% 
  count(education_detailed) %>% 
  ggplot(mapping = aes(x = factor(education_detailed), y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Education Detailed, All Records") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Educational Attainment",
       y = NULL)
```

Vacancy: Value is reported as "0" according to IPUMs. Note there are no vacancy results by default of the structure of census data read in (confirmed in the distribution of the variable).

```{r}
acs_educ %>% 
  ggplot(aes(x = vacancy)) +
  geom_density(color = "blue", fill = alpha("blue", 0.3)) +
  theme_minimal() +
  ggtitle("Vacancy Variable Results") +
  ylab("Density")
```

Isolate the data to 19 and 20 year-olds. This is the age-range included in the college readiness calculation.
```{r}
acs_clean <- acs_educ %>%
  filter(age == 19 | age == 20) 
```

Examine the group quarters variable, we want to include both households and Group Quarters in this metric as both are relevant to the college readiness of a geography.

IPUMS includes the following categories:
0: Vacancy
1: Households under 1970 definition
2: Additional households under 1990 definition
3: Institutions
4: Other group quarters
5: Additional households under 2000 definition
6: Fragments

Check the distribution of GQ categories. Only households and group quarters should be included (no vacancy or fragments).
```{r}
acs_clean %>%  
  count(gq) %>% 
  ggplot(mapping = aes(x = gq, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("GQ, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "GQ",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

### Create race variable

Evaluate the values in the RACE and HISPAN variables.

* IPUMS documented values for RACE: 
    + 1 White
    + 2 Black/African American/Negro
    + 3 American Indian or Alaska Native 
    + 4 Chinese 
    + 5 Japanese
    + 6 Other Asian or Pacific Islander 
    + 7 Other race 
    + 8 Two major races 
    + 9 Three or more major races

* IPUMS documented values for HISPAN: 
    + 0 Not Hispanic 
    + 1 Mexican 
    + 2 Puerto Rican 
    + 3 Cuban 
    + 4 Other 
    + 9 Not Reported 

Look at the distribution of values for the race and hispan variables.
```{r}
acs_clean %>% 
  count(race) %>% 
  ggplot(mapping = aes(x = race, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Race, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Race",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

acs_clean %>% 
  count(hispan) %>% 
  ggplot(mapping = aes(x = hispan, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Hispan, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Hispan",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

Create the race/ethnicity variable. For race/ethnicity categories that are not coded as Hispanic, Hispan must be equal to "Not Hispanic". 

Rename the values from number category to race label: 
  +Race is Black/African American and Hispan is Not Hispanic = "Black, Non-Hispanic"
  +Hispan is not equal to Not Hispanic = "Hispanic"
  +Race is not Black or White and Hispan is Not Hispanic  = "Other Races and Ethnicities" 
  +Race is White and Hispan is Not Hispanic = "White, Non-Hispanic" 
```{r}
acs_clean <- acs_clean %>%
  mutate(subgroup_race = case_when((hispan == "Not Hispanic" & race == "White") ~ "White, Non-Hispanic",
                              (hispan == "Not Hispanic" & race == "Black/African American") ~ "Black, Non-Hispanic",
                              (hispan == "Not Hispanic" & !race %in% c("Black/African American", "White")) ~ "Other Races and Ethnicities",
                               hispan != "Not Hispanic" ~ "Hispanic"
  ))

```

Look at the race/ethnicity subgroup distribution.
```{r}

acs_clean %>% 
  count(subgroup_race) %>% 
  ggplot(mapping = aes(x = factor(subgroup_race), y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Race/ethnicity, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Race/ethnicity",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

### Create gender variable

Evaluate the values in the gender variable.

* IPUMS documented values for SEX: 
    + 1 Male
    + 2 Female
    + 9 Missing/blank 

Look at the distribution of values for the sex variable. There are no missing values in the data and the records are reported in an appropriate format.
```{r}
acs_clean %>% 
  count(sex) %>% 
  ggplot(mapping = aes(x = sex, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("sex, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Sex",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

Rename the variable to subgroup_gender. The variable terms remain the same but any values outside of Male and Female are mutated to NA character variables. Though there are no missing values in the current data let's leave this in the case of future ACS surveys including missing values for this variable. 
```{r}
acs_clean <- acs_clean %>% 
  mutate(subgroup_gender = case_when(sex == "Male" ~ "Male",
                                     sex == "Female" ~ "Female",
                                     TRUE ~ NA_character_))
```

### Create disability variable

The ACS includes 5 variables covering physical and mental disabilities (DIFFCARE, DIFFSENS, DIFFMOB, DIFFPHYS, DIFFREM). To make these variables more clear, first rename them.

```{r}
acs_clean <- acs_clean %>% 
  rename(self_care_difficulty = diffcare,
         vision_hearing_difficulty = diffsens,
         independent_living_difficulty = diffmob,
         ambulatory_difficulty = diffphys,
         cognitive_difficulty = diffrem)
```

Evaluate the values in these variables and create an overall subgroup for disability.
We will count an individual to be disabled if they answer yes or have any of these difficulties. 

* IPUMS documented values for self_care_difficulty: 
    + 0 N/A
    + 1 No
    + 2 Yes 

Plot the options for self_care_difficulty below.
```{r}

acs_clean %>% 
  count(self_care_difficulty) %>% 
  ggplot(mapping = aes(x = self_care_difficulty, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Self-care difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "self_care_difficulty",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

* IPUMS documented values for  vision_hearing_difficulty: 
    + 0 N/A
    + 1 No vision or hearing difficulty
    + 2 Has vision or hearing difficulty

Plot the options for  vision_hearing_difficulty below.
```{r}

acs_clean %>% 
  count( vision_hearing_difficulty) %>% 
  ggplot(mapping = aes(x =  vision_hearing_difficulty, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Vision or Hearing difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = " vision_hearing_difficulty",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

* IPUMS documented values for independent_living_difficulty: 
    + 0 N/A
    + 1 No independent living difficulty
    + 2 Has independent living difficulty

Plot the options for independent_living_difficulty below.
```{r}

acs_clean %>% 
  count(independent_living_difficulty) %>% 
  ggplot(mapping = aes(x = independent_living_difficulty, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Independent living difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "independent_living_difficulty",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

* IPUMS documented values for ambulatory_difficulty: 
    + 0 N/A
    + 1 No ambulatory difficulty
    + 2 Has ambulatory difficulty 
  
Plot the options for ambulatory_difficulty below.
```{r}

acs_clean %>% 
  count(ambulatory_difficulty) %>% 
  ggplot(mapping = aes(x = ambulatory_difficulty, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Ambulatory difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "ambulatory_difficulty",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```
  
* IPUMS documented values for cognitive_difficulty: 
    + 0 N/A
    + 1 No cognitive difficulty
    + 2 Has cognitive difficulty 
  
Plot the options for cognitive_difficulty below.
```{r}
acs_clean %>% 
  count(cognitive_difficulty) %>% 
  ggplot(mapping = aes(x = cognitive_difficulty, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Cognitive difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "cognitive_difficulty",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

Create the subgroup for disability. 
```{r}
acs_clean <- acs_clean %>% 
  mutate(subgroup_disability = case_when(cognitive_difficulty == "Has cognitive difficulty" |
                                           ambulatory_difficulty == "Has ambulatory difficulty" |
                                           independent_living_difficulty == "Has independent living difficulty" |
                                            vision_hearing_difficulty == "Has vision or hearing difficulty" |
                                           self_care_difficulty == "Yes" ~ "with disabiliy",
                                         TRUE ~ "without disability"))
  
```

Check the variable breakout. 
```{r}
acs_clean %>% 
  count(subgroup_disability) %>% 
  ggplot(mapping = aes(x = subgroup_disability, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Subgroup Disability, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Disability",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

## Merge Crosswalk 

Create a variable in the ACS data indicating whether the survey is pre or post-2022. This will be used to join on the correct crosswalk information.
```{r}
acs_clean <- acs_clean %>% 
  mutate(crosswalk_period = ifelse(year < 2022, "pre-2022", "2022"))

```

Check that the assignment worked. All years prior to 2022 should be designated "pre-2022".
```{r}
acs_clean %>% 
  group_by(crosswalk_period, year) %>% 
  count()
```

Join the cleaned ACS data onto the crosswalk.
```{r}
acs_clean <- left_join(acs_clean, puma_county_crosswalk, by=c("crosswalk_period", "statefip","puma"), relationship = "many-to-many")
```

Drop any observations with NA for afact (i.e. there is no county of interest overlapping this PUMA).
```{r}
acs_clean <- acs_clean %>% 
  drop_na(afact)
```

Also filter out cases where AFACT is equal to zero. These cases will not be counted in the metric calculation.
```{r}
acs_clean <- acs_clean %>% 
  filter(afact > 0)
```

## Prepare comuptational variables
Adjust the person weight to account for PUMA-to-place mapping (those where the PUMA is not entirely inside the place).
```{r}
acs_clean <- acs_clean %>%
  mutate(perwt = perwt*afact) 
```

Create a binary college_ready variable indicating whether the individual has a HS degree or not (including GED as HS degree equivalent). IPUMS codes  HS graduate or GED (62) and above are all considered to meet this requirement.
```{r}
acs_clean <- acs_clean %>% 
  mutate(college_ready = ifelse(education_detailed >= 62, 1, 0)) 
```

Check how many records, if any, have NA reported for education_detailed after filtering (this should be zero).
```{r}
acs_clean %>%
  filter(is.na(education_detailed)) %>% 
  group_by(pernum) %>% 
  count()
```

Check the distribution of the education_detailed variable one last time - there should be no NA values included. 
```{r}
acs_clean %>% 
  count(education_detailed) %>% 
  ggplot(mapping = aes(x = factor(education_detailed), y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Education Detailed, All Records") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Educational Attainment",
       y = NULL)
```

Confirm there are no vacant properties included in the data.
```{r}
acs_clean %>%
  filter(is.na(vacancy)) %>% 
  group_by(pernum) %>% 
  count()
```

## Read replicate weights 

Read in person-level replicate weights for the 19 and 20 year old population. These will be used in creating standard errors for the college ready calculation. 
```{r}
repwts_person <- ipums_repwt_college(
  extract_name = "college_replicate_weights",
  extract_description = "Person replicate weights for College Readiness Metric Predictors. American Community Survey, years 2018 and 2022 (5-year).",
  survey = list("us2018c", "us2021c")
)  %>% 
  select(-cbserial, -cbpernum)
```

Look at the distribution of ACS survey samples in the data. The number of different samples should align with the number of surveys selected in the extract ipums function.
```{r}
repwts_person %>% 
  count(sample) %>% 
  ggplot(mapping = aes(x = sample, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Samples, All Records in Repwt File") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Samples",
       y = NULL)
```


Remove the sample variable.
```{r}
repwts_person <- repwts_person %>% 
  select(-sample)
```


## Setup Survey Design 

Set up the survey design using instructions from IPUMS. Join the replicate weights onto the acs survey data using the unique person ID created for both.
```{r}
acs_survey_all <- acs_clean %>%
  left_join(repwts_person, by = c("unique_person_id")) %>% 
  mutate(across(matches('repwtp[0-9]+'),
                     ~.x * afact)) %>% 
  as_survey_rep(weights = perwt, 
                repweights = matches("repwtp[0-9]+"),
                type = "ACS",
                mse = TRUE) 
```

## Create college readiness metric

Create the college ready metric. 

Objective: get the percent of individuals between 19 and 20 that have a HS degree for each county in the US.

Aggregation should be weighted by PERWT (this is a person level statistic).

Check national college readiness ratio. Compute the ratio (share hs degree) for 2018, 2021 and 2022 nationally and show results. This serves as a gut-check, we would expect the results to be above 80% and below 95%.
```{r}
acs_survey_all %>%
  group_by(year) %>%
  summarise(
    share_hs_degree = survey_mean(college_ready, vartype = "ci"),
    count = unweighted(n())
  ) %>% 
  ungroup() %>% 
  reactable()
```

### All and Subgroups

Create share college ready by race/ethnicity at the county-level (5-year data). Include a calculation of the effective sample count for each county and subgroup, defined as the sum of the afact variable. This is used to create a cutoff for data quality based on the actual number of survey records being used in the calculation.
```{r}
metrics_education_subgroup_race <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, county, subgroup_race) %>%
 summarise(
    share_hs_degree = survey_mean(college_ready, vartype = "ci"),
    effective_sample = unweighted(sum(afact))
  ) %>% 
  ungroup() %>% 
  mutate(subgroup_type = "race-ethnicity") %>% 
  rename(subgroup = subgroup_race)
```

Create share college ready by gender at the county-level (5-year data).
```{r}
metrics_education_subgroup_gender <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, county, subgroup_gender) %>%
 summarise(
    share_hs_degree = survey_mean(college_ready, vartype = "ci"),
    effective_sample = unweighted(sum(afact))
  ) %>% 
  ungroup() %>% 
  mutate(subgroup_type = "gender") %>% 
  rename(subgroup = subgroup_gender)
```

Create share college ready by disability at the county-level (5-year data).
```{r}
metrics_education_subgroup_disability <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, county, subgroup_disability) %>%
 summarise(
    share_hs_degree = survey_mean(college_ready, vartype = "ci"),
    effective_sample = unweighted(sum(afact))
  ) %>% 
  ungroup() %>% 
  mutate(subgroup_type = "disability")%>% 
  rename(subgroup = subgroup_disability)
```

Create the share college ready measure for all values in the 5-year data (non-subgroup). This value will be merged onto the subgroup data. 
```{r}
metrics_education_subgroup_all <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, county) %>%
  summarise(
   share_hs_degree = survey_mean(college_ready, vartype = "ci"),
   effective_sample = unweighted(sum(afact))
  ) %>% 
  ungroup() %>% 
  mutate(subgroup_type = "all",
         subgroup = "All")
```

Append the "All" version of the 5-year data with the subgroup results.
```{r}
metrics_education_sub <- bind_rows(metrics_education_subgroup_race, metrics_education_subgroup_gender,
                                   metrics_education_subgroup_disability, metrics_education_subgroup_all)
```

Check that all subgroup types are included. We should see all, disability, gender and race-ethnicity.
```{r}
metrics_education_sub %>% 
  group_by(subgroup_type) %>% 
  count()
```

Cap upper-bound confidence intervals at 100% (above would be an illogical option). If it is greater than 1, make the share equal to exactly 1.
```{r}
metrics_education_sub <- metrics_education_sub %>% 
  mutate(share_hs_degree_upp =  ifelse(share_hs_degree_upp > 1, 1, share_hs_degree_upp))
```

*Create an indicator for data quality and suppression*

Merge the data quality flags and create the final data quality metric based on both size and geographic allocation.
```{r}
metrics_education_sub <- left_join(metrics_education_sub, county_puma, by=c("crosswalk_period", "statefip","county"))
```

Tabulate effective sample counts for each county by sugroup, defined as the sum of the afact for all records in that county. Look at the distribution of counties by potential cutoffs (30, 100, 300). This is to measure data quality for each county based on the number of records reported. 
```{r}
metrics_education_sub %>%
  mutate(
    effective_sample_cutoffs = case_when(
      effective_sample < 30 ~ "Less than 30",
      effective_sample >= 30 &
        effective_sample <= 100 ~ "Over 30 but 100 or less",
      effective_sample > 100 &
        effective_sample <= 300 ~ "Over 100 but 300 or less",
      TRUE ~ "Greater than 300"
    ),
    effective_sample_cutoffs = factor(
      effective_sample_cutoffs,
      levels = c(
        "Less than 30",
        "Over 30 but 100 or less",
        "Over 100 but 300 or less",
        "Greater than 300"
      )
    )
  ) %>% 
  group_by(year, subgroup_type) %>% 
  mutate(yearly_total = n()) %>% 
  ungroup() %>% 
  group_by(year, effective_sample_cutoffs, subgroup_type) %>%
  summarize(n = n(), suppression_share = n()/unique(yearly_total)) %>% # yearly value has one unique value per year
  reactable()
```

Generate the quality variable for each county.
```{r}
metrics_education_sub <- metrics_education_sub %>% 
  mutate(effective_sample_flag = ifelse(effective_sample < 100, 1, 0),
         share_hs_degree_quality = case_when(effective_sample_flag == 0 & geographic_allocation_quality == 1 ~ 1,
                                             effective_sample_flag == 0 & geographic_allocation_quality == 2 ~ 2,
                                             effective_sample_flag == 0 & geographic_allocation_quality == 3 ~ 3,
                                             effective_sample_flag == 1 ~ 3)
  )
```

We do not want to show values that are calculated from less than 30 responses in the data. These points will be suppressed and shown as missing or NA. Suppress the results for values generated from less than 30 responses.
```{r}
metrics_education_sub <- metrics_education_sub %>% 
    mutate(across(c(share_hs_degree, share_hs_degree_low, share_hs_degree_upp), ~if_else(effective_sample < 30, NA_integer_, .))) 
```

Keep only relevant variables for subgroup data and sort by year, state and county.
```{r}
metrics_education_sub_clean <- metrics_education_sub %>%
  select(year,
         statefip,
         county,
         subgroup_type, 
         subgroup,
         share_hs_degree,
         share_hs_degree_lb = share_hs_degree_low,
         share_hs_degree_ub = share_hs_degree_upp,
         share_hs_degree_quality) %>%
  arrange(year, statefip, county)
```

Keep only relevant data for all data, and sort by year, state and county.
```{r}
metrics_education_all_clean <- metrics_education_sub %>%
  filter(subgroup == "All") %>% 
  select(year,
         statefip,
         county,
         share_hs_degree,
         share_hs_degree_lb = share_hs_degree_low,
         share_hs_degree_ub = share_hs_degree_upp,
         share_hs_degree_quality) %>%
  arrange(year, statefip, county)
```

### Evaluate results

Summarize the predictors the all cateogry and categories by subgroups.
```{r}
metrics_education_all_clean %>% 
  select(share_hs_degree:share_hs_degree_quality) %>% 
  summary()

metrics_education_sub_clean %>% 
  select(share_hs_degree:share_hs_degree_quality) %>% 
  summary()
```

Look at distribution of hs_degree share by county.
```{r}
metrics_education_all_clean %>% 
  filter(year == 2021) %>% 
  select(share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("Distribution by all palces of share hs_degree, 2021 (5-year data)") +
  ylab("Density")
```

### Race distribution
Look at distribution of hs_degree share by county by race.
```{r}

metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "Black, Non-Hispanic") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, Black") +
  ylab("Density")

metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "Hispanic") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, Hispanic") +
  ylab("Density")

metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "Other Races and Ethnicities") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, Other Races and Ethnicities") +
  ylab("Density")

metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "White, Non-Hispanic") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, White, Non-Hispanic") +
  ylab("Density")

```

### Gender distribution
Look at distribution of hs_degree share by county by gender.
```{r}
metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "Male") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, males") +
  ylab("Density")

metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "Female") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, females") +
  ylab("Density")
```

### Disability distribution

Look at distribution of hs_degree share by county by disability status.
```{r}

metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "with disabiliy") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, with disabilities") +
  ylab("Density")

metrics_education_sub_clean %>% 
  filter(year == 2021, subgroup == "without disability") %>% 
  select(county, share_hs_degree) %>% 
  ggplot(aes(x = share_hs_degree)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, without disabilities") +
  ylab("Density")

```

Look at the counts of the quality flag.
```{r}
metrics_education_all_clean %>% 
  select(share_hs_degree_quality) %>% 
  ggplot(aes(x = share_hs_degree_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  ggtitle("Quality Flag (5-year data no subgroups)") +
  ylab("Count")

metrics_education_sub_clean %>% 
  select(share_hs_degree_quality) %>% 
  ggplot(aes(x = share_hs_degree_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  ggtitle("Quality Flag (5-year data with subgroups") +
  ylab("Count")
```

Tabulate share of data suppressed by year.
```{r}
metrics_education_all_clean %>% 
  group_by(year) %>% 
  filter(is.na(share_hs_degree)) %>% 
  count()

metrics_education_sub_clean %>% 
  group_by(year) %>% 
  filter(is.na(share_hs_degree)) %>% 
  count()
```

## Export 

Rename state.
```{r}
metrics_education_all_clean <- metrics_education_all_clean %>% 
  rename("state" = "statefip")

metrics_education_sub_clean <- metrics_education_sub_clean %>% 
  rename("state" = "statefip")
```

Order the variables how we want.
```{r}
metrics_education_all_clean <- metrics_education_all_clean %>% 
  select(year, state, county, share_hs_degree, 
         share_hs_degree_lb, share_hs_degree_ub, share_hs_degree_quality)

metrics_education_sub_clean <- metrics_education_sub_clean %>% 
  select(year, state, county, subgroup_type, subgroup, share_hs_degree,
         share_hs_degree_lb, share_hs_degree_ub, share_hs_degree_quality)
```

Export as CSV

```{r}
write_csv(metrics_education_all_clean, here::here("08_education", "data", "final", "metrics_college_county_all_longitudinal.csv"))
write_csv(metrics_education_sub_clean, here::here("08_education", "data", "final", "metrics_college_county_sub-groups_longitudinal.csv"))
```





