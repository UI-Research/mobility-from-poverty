---
title: "Housing Value"
author: " Manu Alcalá Kovalski"
date: now
format:
  html:
    embed-resources: true
    toc: true
    toc_float: true
    code-fold: show
    code-tools: true
editor_options: 
  chunk_output_type: console
execute:
  warning: false
---

```{=html}
<style>
@import url('https://fonts.googleapis.com/css?family=Lato&display=swap');
</style>
```
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

This program creates the **Housing Value** metric defined as the ratio between the share of a community’s housing wealth held by a racial or ethnic group to the share of households of the same group metric

Initially written by Jung Hyun Choi and updated by Manu Alcalá Kovalski in 2023-2024.

## Process

-   [Housekeeping](#housekeeping)
-   [Read Data](#read-data)
-   [Clean Data](#clean-data)
-   [Merge Crosswalk](#merge-crosswalk)
-   [Create Housing Value Metric](#create-metric)
-   [Evaluate Results](#evaluate-results)
-   [Export](#export)

## Housekeeping {#sec-housekeeping}

```{r}
#| label: setup

options(scipen = 999)
librarian::shelf(
  tidyverse,
  ipumsr,
  here,
  glue,
  labelled,
  skimr,
  UrbanInstitute / urbnthemes,
  tidylog,
  assertr
)
set_urbn_defaults(style = "print")
```

### Read Data {#sec-read-data}

We extract the 1 year ACS files from the IPUMS API using `ipumsr`. You will need to have an API key in order to do so. If you don't have one, you can register to the [IPUMS USA](https://uma.pop.umn.edu/usa/user/new?return_url=https%3A%2F%2Fusa.ipums.org%2Fusa-action%2Fmenu) data collection and create an API key.

By default, `ipumsr` API functions assume that your key is stored in the **IPUMS_API_KEY** environment variable. You can also provide your key directly to these functions, but storing it in an environment variable saves you some typing and helps prevent you from inadvertently sharing your key with others (for instance, on GitHub).

You can save your API key to the IPUMS_API_KEY environment variable with `set_ipums_api_key(api_key = "paste-your-key-here", save = TRUE)`. This will add your API key to your .Renviron file in your user home directory.

```{r}
#| label: query-ipums-api
#| cache: true
#| eval: false
## 2.1. ACS: keep households living not living in gq

# Run this the first time you run this code to avoid requesting the same data
# multiple times

acs_vars <- c("YEAR", "SAMPLE", "SERIAL", "CBSERIAL", "HHWT", "CLUSTER", "state", "county", "MET2013", "CITY", "PUMA", "STRATA", "GQ", "OWNERSHP", "OWNERSHPD", "VALUEH", "PERNUM", "PERWT", "RACE", "RACED", "HISPAN", "HISPAND", "AGE")

years <- 2014:2022
# usa_ext_def <- define_extract_usa(
#   description = "ACS 1 Year 2014-2022",
#   samples = paste0("us", years, "a"),
#   variables = acs_vars
# )
#
# usa_ext_submitted <- submit_extract(usa_ext_def)
# usa_ext_complete <- wait_for_extract(usa_ext_submitted)
#
# # download_extract() will return a character vector including the file paths
# # to all downloaded files.
#
# filepath <- download_extract(usa_ext_complete,
#   download_dir = here("01_financial-well-being/data")
# )
```

### Clean data {#sec-clean-data}

We load the 2014-2022 1 Year ACS microdata we downloaded from IPUMS above. IPUMS loads the data as a person-level data set with some household variables.Therefore, we can analyze the data at the household level by keeping the first person sampled in the household.

```{r}
#| label: load-acs
#| cache: true
#| dependson: "import-acs-one-year"
#| include: false

# Set microdata to whatever the file you downloaded in the previous chunk is called
microdata <- "usa_00010.xml"

acs1yr_raw <-
  read_ipums_micro(here(glue("01_financial-well-being/data/{microdata}"))) |>
  janitor::clean_names() |>
  rename(
    ownership = ownershp,
    state = statefip,
    county = countyfip,
  ) |>
  filter(
    year != 2020,
    pernum == 1
  )
```

The [ipumsr](https://tech.popdata.org/ipumsr/articles/value-labels.html#remove-unused-value-labels) documentation says that:

> "labelled vectors are not intended for use throughout the entire analysis process. Instead, they should be used during the initial data preparation process to convert raw data into values that are more meaningful. These can then be converted to other variable types (often factors) for analysis. Unfortunately, this isn’t a process that can typically be automated, as it depends primarily on the research questions the data will be used to address. However, ipumsr provides several functions to manipulate value labels to make this process easier.

A useful way of finding missing value labels is to call `ipums_var_info(acs1yr)` and inspect the `val_labels`.

Notice that missing values for "value of housing units" (`valueh`) are labelled as 9999998, and 9999999. We fix this before doing any computations.

```{r}
#| label: handle-missingness


acs1yr <-
  acs1yr_raw |>
  mutate(
    valueh = lbl_na_if(valueh, ~ .lbl %in% c("Missing", "N/A")),
  )

acs1yr |>
  assertr::verify(valueh < 9999998 | is.na(valueh))
```

Next, we exclude individuals living in group quarters because we only want households for this metric. In particular, we exclude people living in places other than housing units (e.g., correctional facilities, nursing homes, mental hospitals, dorms, barracks, group homes, missions). For more information, see the [variable description](https://usa.ipums.org/usa-action/variables/GQ#codes_section) on IPUMS USA.

```{r}
#| label: keep-households-only
acs1yr <-
  acs1yr |>
  filter(!(gq %in% c("Group quarters--Institutions", "Other group quarters")))
```

FIPS codes should always contain leading zeros so that state codes are two digits, county codes are three digits, and place codes are five digits.

```{r}
#| label: clean-fips-codes

acs1yr <-
  acs1yr |>
  mutate(
    across(c(state, county, city, puma), as.character),
    state = str_pad(state, width = 2, pad = "0", side = "left"),
    county = str_pad(county, width = 3, pad = "0", side = "left"),
    city = str_pad(city, width = 5, pad = "0", side = "left"),
    puma = str_pad(puma, width = 5, pad = "0", side = "left")
  )
```

We create two age subgroups: households over 45 and households under 45

```{r}
#| label: add-age-subgroup

acs1yr <-
  acs1yr |>
  mutate(subgroup = if_else(age >= 45, "Over or exactly 45 years old", "Under 45 years old"))
```

We collapse IPUMS race and ethnicity categories into white non-hispanic, Black non-hispanic, other non-hispanic, and

```{r}
#| label: add-race-ethnicity-subgroup


acs1yr <-
  acs1yr |>
  mutate(
    race = lbl_relabel(race, lbl(10, "Other") ~ .lbl %in% c("American Indian or Alaska Native", "Chinese", "Japanese", "Other Asian or Pacific Islander", "Other race, nec", "Two major races", "Three or more major races")),
    across(c(race, hispan), as_factor)
  ) |>
  mutate(
    race_ethnicity = case_when(
      race == "White" & hispan == "Not Hispanic" ~ "white_nh",
      race == "Black/African American" & hispan == "Not Hispanic" ~ "black_nh",
      race == "Other" & hispan == "Not Hispanic" ~ "other_nh",
      hispan != "Not Hispanic" ~ "hispanic",
      .default = NA_character_
    ),
    race_ethnicity = factor(race_ethnicity,
      levels = c(
        "white_nh",
        "black_nh",
        "hispanic",
        "other_nh"
      )
    )
  )
```

## Merge Crosswalk {#sec-merge-crosswalk}

We merge our 1-year ACS data with PUMA-county and PUMA-place geocodes to get county and place boundaries.

For 2022 ACS and onward we use a crosswalk going from 2020 PUMA to 2020 county. For pre-2022 ACS data, we use a crosswalk from 2012 PUMA to 2014 county.

The weight of each household is adjusted by the area of the PUMA that falls into a given County/Place

```{r}
#| label: define-crosswalk-years

acs1yr <-
  acs1yr |>
  mutate(crosswalk_period = if_else(year < 2022, "pre-2022", "2022"))
```

::: panel-tabset
#### County

```{r}
#| label: puma-to-county-crosswalk

puma_county_crosswalk <-
  read_csv(here::here(
    "geographic-crosswalks",
    "data",
    "crosswalk_puma_to_county.csv"
  )) |>
  rename(
    state = statefip,
  ) |>
  filter(state != "72")


households_county <-
  acs1yr |>
  right_join(puma_county_crosswalk,
    by = c("state", "puma", "crosswalk_period")
  ) |>
  # if county isn't present in the ACS use county codes from PUMA-County crosswalk
  mutate(
    county = if_else(county.x != "000", county.x, county.y),
    hhwt = if_else(county.x != "000", hhwt, hhwt * afact),
    sum_products = if_else(county.x != "000", 1, sum_products)
  ) |>
  select(-c(county.x, county.y))
```

#### Place

```{r}
#| label: puma-to-place-crosswalk


puma_place_crosswalk <-
  read_csv(here::here(
    "geographic-crosswalks",
    "data",
    "crosswalk_puma_to_place.csv"
  )) |>
  rename(state = statefip)

households_place <-
  acs1yr |>
  right_join(puma_place_crosswalk,
    by = c("state", "puma", "crosswalk_period")
  ) |>
  mutate(hhwt = hhwt * afact)
```
:::

## Create Housing Value Metric {#sec-create-metric}

### Housing Share

We will now compute the share of households by race and ethnicity (i.e., total number of households for each race and ethnic group divided by the total number of households)

::: panel-tabset
### County

```{r}
#| label: share-of-households-by-race-ethnicity-county

share_households_county <-
  households_county |>
  select(year, state, county, hhwt, race_ethnicity) |>
  summarise(
    household = sum(hhwt),
    .by = c(year, state, county, race_ethnicity)
  ) |>
  mutate(
    total = sum(household),
    .by = c(year, state, county)
  ) |>
  mutate(share_households = household / total) |>
  select(year, state, county, race_ethnicity, share_households)

share_households_county_subgroup <-
  households_county |>
  select(year, state, county, hhwt, race_ethnicity, subgroup) |>
  summarise(
    household = sum(hhwt),
    .by = c(year, state, county, race_ethnicity, subgroup)
  ) |>
  mutate(
    total = sum(household),
    .by = c(year, state, county, subgroup)
  ) |>
  mutate(share_households = household / total) |>
  select(year, state, county, race_ethnicity, subgroup, share_households)
```

**Check:** Is `share_households` between 0 and 1?

```{r}
#| label: check-share-hh-county-check
stopifnot(min(share_households_county$share_households) >= 0)
stopifnot(max(share_households_county$share_households) <= 1)
```

We visualize the distribution of the share of households by race and ethnicity

```{r}
#| label: check-share-households-county

share_households_county |>
  drop_na() |>
  ggplot(aes(x = share_households)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 0.02) +
  facet_wrap(. ~ race_ethnicity) +
  labs(
    title = "Share of Households by Race and Ethnicity",
    subtitle = "County",
    y = "Count",
    x = "Share of Households"
  )

summary(share_households_county)
skimr::skim(share_households_county)
```

```{r}
#| label: check-share-households-county-age

share_households_county_subgroup |>
  ggplot(aes(x = share_households)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 0.02) +
  facet_wrap(race_ethnicity ~ subgroup, ncol = 2) +
  labs(
    title = "Share of Households by Race and Ethnicity",
    subtitle = "County",
    y = "Count",
    x = "Share of Households"
  )

summary(share_households_county_subgroup)
skimr::skim(share_households_county_subgroup)
```

### Place

```{r}
#| label:  share-of-households-by-race-ethnicity-place

share_households_place <-
  households_place |>
  select(year, state, place, hhwt, race_ethnicity) |>
  summarise(
    households = sum(hhwt),
    .by = c(year, state, place, race_ethnicity)
  ) |>
  mutate(
    total_households = sum(households),
    .by = c(year, state, place)
  ) |>
  mutate(share_households = households / total_households) |>
  select(year, state, place, race_ethnicity, share_households)

share_households_place_subgroup <-
  households_place |>
  select(year, state, place, hhwt, race_ethnicity, subgroup) |>
  summarise(
    households = sum(hhwt),
    .by = c(year, state, place, race_ethnicity, subgroup)
  ) |>
  mutate(
    total_households = sum(households),
    .by = c(year, state, place, subgroup)
  ) |>
  mutate(share_households = households / total_households) |>
  select(year, state, place, race_ethnicity, subgroup, share_households)
```

**Check:** Is `share_households` between 0 and 1?

```{r}
#| label: check-share-households-race-ethnicity-place

stopifnot(min(share_households_place$share_households) >= 0)
stopifnot(max(share_households_place$share_households) <= 1)

share_households_place |>
  ggplot(aes(x = share_households)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 0.02) +
  facet_wrap(. ~ race_ethnicity) +
  labs(
    title = "Share of Households by Race and Ethnicity",
    subtitle = "Place",
    y = "Count",
    x = "Share of Households"
  )

skimr::skim(share_households_place)
summary(share_households_place)
```

```{r}
#| label: check-share-households-place-age

stopifnot(min(share_households_place_subgroup$share_households) >= 0)
stopifnot(max(share_households_place_subgroup$share_households) <= 1)

share_households_place_subgroup |>
  ggplot(aes(x = share_households)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 0.02) +
  facet_wrap(subgroup ~ race_ethnicity, ncol = 2) +
  labs(
    title = "Share of Households by Race and Ethnicity",
    subtitle = "Place",
    y = "Count",
    x = "Share of Households"
  )

skimr::skim(share_households_place_subgroup)
summary(share_households_place_subgroup)
```

:::

### Housing Value Share

We keep observations for homeowners only in order to calculate total aggregated housing wealth for homeowners for each race and ethnic group divided by the total aggregated housing value

```{r}
#| label: total-house-values-by-race

house_value_by_race <- function(data, ...) {
  data |>
    mutate(ownership = as_factor(ownership)) |>
    filter(ownership == "Owned or being bought (loan)") |>
    summarise(
      house_value = sum(valueh * hhwt),
      home_owners = n(),
      .by = c(year, state, race_ethnicity, ...)
    )
}

house_value_county_subgroup <- house_value_by_race(households_county, county, subgroup)
house_value_county <- house_value_by_race(households_county, county)


house_value_place_subgroup <- house_value_by_race(households_place, place, subgroup)
house_value_place <- house_value_by_race(households_place, place)
```


The metrics for the ACS indices are based on:
- (1) sample size of each race and ethnic household at the county/place and 
- (2) the number of observations that comes from the specific county/place calculated from the PUMA-county/place crosswalk.

Therefore, the data quality is poor for counties/places with a extremely small number of households (N). To assess the data quality of counties/places with larger N, we need to consider what percent of data for the county/place actually came from the county/place itself.

In particular,

-   Data quality is good (`1`): N is greater than 30 and more than 75% of observations are from the county/place.
-   Data quality is marginal (`2`): N is greater than 30 but only 35% to 75% of observations are from the county/place.
-   Data quality is poor (`3`): N is less than 30 **or** if less than 35% of observations are from the county/place

```{r}
#| label: quality-check-flag-functions

construct_quality_flag <- function(x, y) {
  case_when(
    x < 30 ~ 3,
    x >= 30 & y < 0.35 ~ 3,
    x >= 30 & y >= 0.35 & y < 0.75 ~ 2,
    x >= 30 & y >= 0.75 ~ 1
  )
}
```

::: {.panel-tabset}

### County

```{r}
#| label: add-quality-check-flags-county

county_quality <-
  households_county |>
  distinct(year, state, county, .keep_all = TRUE) |>
  select(year, state, county, sum_products)

house_value_county <-
  house_value_county |>
  left_join(county_quality, by = c("year", "state", "county")) |>
  mutate(
    ratio_house_value_households_quality = construct_quality_flag(home_owners, sum_products)
  )

house_value_county |>
  ggplot(aes(x = ratio_house_value_households_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  labs(
    title = "Quality Flag",
    subtitle = "County",
    x = "Quality Flag",
    y = "Count"
  )
```


```{r}
#| label: add-quality-check-flags-county-subgroup

house_value_county_subgroup <-
  house_value_county_subgroup |>
  left_join(county_quality, by = c("year", "state", "county")) |>
  mutate(
    ratio_house_value_households_quality = construct_quality_flag(home_owners, sum_products)
  )

house_value_county_subgroup |>
  ggplot(aes(x = ratio_house_value_households_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  labs(
    title = "Quality Flag",
    subtitle = "County",
    x = "Quality Flag",
    y = "Count"
  ) +
  facet_wrap(. ~ subgroup, ncol = 2)
```

### Place

```{r}
#| label: add-quality-check-flags-place

place_quality <-
  households_place %>%
  distinct(state, place, .keep_all = TRUE) |>
  select(state, place, sum_products)

house_value_place <-
  house_value_place |>
  left_join(place_quality,
    by = c("state", "place")
  ) |>
  mutate(
    ratio_house_value_households_quality = construct_quality_flag(home_owners, sum_products)
  )


house_value_place |>
  ggplot(aes(x = ratio_house_value_households_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  labs(
    title = "Quality Flag",
    subtitle = "Place",
    x = "Quality Flag",
    y = "Count"
  )
```


```{r}
#| label: add-quality-check-flags-place-subgroup

house_value_place_subgroup <-
  house_value_place_subgroup |>
  left_join(place_quality,
    by = c("state", "place")
  ) |>
  mutate(
    ratio_house_value_households_quality = construct_quality_flag(home_owners, sum_products)
  )


house_value_place_subgroup |>
  ggplot(aes(x = ratio_house_value_households_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  labs(
    title = "Quality Flag",
    subtitle = "Place, Age Over 45 Subgroup",
    x = "Quality Flag",
    y = "Count"
  ) +
  facet_wrap(race_ethnicity ~ subgroup, ncol = 2)
```
:::


```{r}
#| label: house-value-by-race-ethnicity

house_value_by_race <- function(data, ...) {
  data |>
    mutate(total_house_value = sum(house_value), .by = c(year, state, ...)) |>
    mutate(share_house_value = house_value / total_house_value) |>
    select(year, state, ..., race_ethnicity, house_value, total_house_value, share_house_value, ratio_house_value_households_quality)
}



house_value_county <- house_value_by_race(house_value_county, county)
house_value_county_subgroup <- house_value_by_race(house_value_county_subgroup, county, subgroup)
house_value_place <- house_value_by_race(house_value_place, place)
house_value_place_subgroup <- house_value_by_race(house_value_place_subgroup, place, subgroup)
```


```{r}
house_value_county |>
  ggplot() +
  geom_density(aes(x = share_house_value),
    color = "blue", fill = alpha("blue", 0.3)
  ) +
  facet_wrap(. ~ race_ethnicity) +
  theme_minimal() +
  labs(
    title = "Share House Value by Race/Ethnicity",
    subtitle = "County",
    x = "Share House Value",
    y = "Density"
  )

house_value_county_subgroup |>
  ggplot() +
  geom_density(aes(x = share_house_value),
    color = "blue", fill = alpha("blue", 0.3)
  ) +
  facet_wrap(race_ethnicity ~ subgroup, ncol = 2) +
  theme_minimal() +
  labs(
    title = "Share House Value by Race/Ethnicity and Age",
    subtitle = "County, Age over 45 Subgroup",
    x = "Share House Value",
    y = "Density"
  )


house_value_place |>
  ggplot() +
  geom_density(aes(x = share_house_value),
    color = "blue", fill = alpha("blue", 0.3)
  ) +
  facet_wrap(. ~ race_ethnicity) +
  theme_minimal() +
  labs(
    title = "Share House Value by Race/Ethnicity",
    subtitle = "Place",
    x = "Share House Value",
    y = "Density"
  )


house_value_place_subgroup |>
  ggplot() +
  geom_density(aes(x = share_house_value),
    color = "blue", fill = alpha("blue", 0.3)
  ) +
  facet_wrap(race_ethnicity ~ subgroup, ncol = 2) +
  theme_minimal() +
  labs(
    title = "Share House Value by Race/Ethnicity and Age",
    subtitle = "Place, Age over 45 Subgroup",
    x = "Share House Value",
    y = "Density"
  )
```

## Create Final Output Data: Merge Household & Housing Value Share

```{r}
#| label: compute-ratio-house-value-households

construct_ratio <- function(share_house_value, share_households) {
  paste0(
    format(round(100 * share_house_value, 1), nsmall = 1),
    "%",
    ":",
    format(round(100 * share_households, 1), nsmall = 1),
    "%"
  ) |>
    str_remove_all(pattern = " ")
}

ratio_house_value_households <- function(households_data, house_value_data, ...) {
  geo_var <- if_else("county" %in% colnames(households_data), "county", "place")
  households_data |>
    left_join(house_value_data,
      by = c("year", "state", geo_var, "race_ethnicity", ...)
    ) |>
    mutate(
      ratio_house_value_households = construct_ratio(share_house_value, share_households),
      .by = c(race_ethnicity, ...)
    ) |>
    arrange(year, state, {{ geo_var }}, ...)
}


reshape_to_wide <- function(data, ...) {
  data |>
    pivot_wider(
      id_cols = c(year, state, ...),
      names_from = race_ethnicity,
      values_from = c(ratio_house_value_households, ratio_house_value_households_quality),
      names_glue = "{race_ethnicity}_{.value}"
    ) %>%
    rename_with(~ str_remove(.x, "ratio_") %>% paste0("ratio_", .), contains("ratio")) %>%
    # order variables according to request
    select(
      year, state, ...,
      ratio_black_nh_house_value_households, ratio_black_nh_house_value_households_quality,
      ratio_hispanic_house_value_households, ratio_hispanic_house_value_households_quality,
      ratio_other_nh_house_value_households, ratio_other_nh_house_value_households_quality,
      ratio_white_nh_house_value_households, ratio_white_nh_house_value_households_quality
    ) %>%
    arrange(year, state, ...)
}
```

```{r}
#| label: calculate-metric

ratio_house_value_households_county <- ratio_house_value_households(
  share_households_county,
  house_value_county
) |>
  reshape_to_wide(county)


ratio_house_value_households_county_subgroup <- ratio_house_value_households(
  share_households_county_subgroup,
  house_value_county_subgroup,
  "subgroup"
) |>
  reshape_to_wide(county, subgroup)

ratio_house_value_households_place <-
  ratio_house_value_households(
    share_households_place,
    house_value_place
  ) |>
  reshape_to_wide(place)

ratio_house_value_households_place_subgroup <-
  ratio_house_value_households(
    share_households_place_subgroup,
    house_value_place_subgroup,
    "subgroup"
  ) |>
  reshape_to_wide(place, subgroup)
```

**Check:** Are there 3,143 counties and 486 places in the final output?

Our metric county data has 3,143 counties as expected for all years prior to 
2022. The metric places data also has the expected 486 places.

```{r}
#| label: check-number-of-counties-places

stopifnot(
  ratio_house_value_households_county |>
    distinct(year, state, county) |>
    count(year) |>
    filter(year != 2022) |>
    pull(n) == 3143
)


stopifnot(
  ratio_house_value_households_place |>
    distinct(year, state, place) |>
    count(year) |>
    filter(year == 2022) |>
    pull(n) == 486
)
```


However, for 2022, the number of counties is 3,146
```{r}
#| label: check-number-of-counties-2022
#| error: true

stopifnot(
  ratio_house_value_households_county |>
    distinct(year, state, county) |>
    count(year) |>
    filter(year == 2022) |>
    pull(n) == 3143
)
```

Further examination shows that there are 5 counties in our metric data that
are not in the county populations file. 
```{r}
#| label: find-extra-counties


all_counties <- read_csv(here::here("geographic-crosswalks", "data", "county-populations.csv")) %>%
  tidylog::filter(year == 2022) %>%
  select(-year)

(extra_counties <-
  ratio_house_value_households_county %>%
  filter(year == 2022) |>
  distinct(state, county) |>
  anti_join(all_counties, by = c("state", "county"))
)
```

At the same time, there are 3 counties in the county populations file that are
not present in our metric data:

```{r}
#| label: find-missing-counties

(
  missing_counties <- ratio_house_value_households_county %>%
    filter(year == 2022) |>
    distinct(state, county) |>
    anti_join(x = all_counties, y = _, by = c("state", "county"))
)
```


## Export {#sec-export}


```{r}
#| label: export-data

export_metric <- function(data, file_type) {
  geography <- ifelse("place" %in% colnames(data), "city", "county")
  geo_var <- ifelse(geography == "city", "place", "county")

  pop_file <-
    read_csv(here::here("geographic-crosswalks", "data", paste0(geo_var, "-populations.csv")))
  data <- data |> left_join(pop_file, by = c("year", "state", geo_var))


  if (file_type == "recent") {
    data <- filter(data, year == max(year)) |> select(-year)
    file_type <- 2022
  }

  if (file_type == "subgroup") {
    data
  }

  output_path <- here(glue("01_financial-well-being/final/households_house_value_race_ethnicity_{file_type}_{geography}.csv"))


  data |>
    relocate(c(state_name, rlang::sym(paste0(geo_var, "_name"))), .after = {{ geo_var }}) |>
    select(-population) |>
    write_csv(file = output_path)
}

export_metric(ratio_house_value_households_county, file_type = "recent")
export_metric(ratio_house_value_households_county, file_type = "all")

ratio_house_value_households_county_subgroup |>
  mutate(subgroup_type = "age", .before = "subgroup") |>
  bind_rows(ratio_house_value_households_county |>
    mutate(
      subgroup_type = "all",
      subgroup = "All"
    )) |>
  arrange(year, state, county, subgroup_type, subgroup) |>
  export_metric(file_type = "subgroup")


export_metric(ratio_house_value_households_place, file_type = "recent")
export_metric(ratio_house_value_households_place, file_type = "all")

ratio_house_value_households_place_subgroup |>
  mutate(subgroup_type = "age", .before = "subgroup") |>
  bind_rows(ratio_house_value_households_place |>
    mutate(
      subgroup_type = "all",
      subgroup = "All"
    )) |>
  arrange(year, state, place, subgroup_type, subgroup) |>
  export_metric(file_type = "subgroup")
```
