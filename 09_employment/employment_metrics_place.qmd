---
title: "Employment Opportunities Predictor, Place-level"
author: "JP Walsh"
date: today
format:
  html:
    toc: true
    toc_float: true
    embed-resources: true
    code-fold: show
execute: 
  warning: false
editor_options: 
  chunk_output_type: console
---

*Program for the creation of the Employment Opportunities Upward Mobility Predictor at the place-level*

ACS Code: Initially written by Tina Chelidze and updated by JP Walsh 2022-2023.

Primary data derived from the IPUMS API.

Based on processes developed by Paul Johnson and Kevin Werner in SAS.

-   [Housekeeping](#housekeeping)
-   [Read Data](#read-data)
-   [Clean Data](#clean-data)
-   [Merge Crosswalk](#merge-crosswalk)
-   [Read replicate weights](#read-replicate-weights)
-   [Setup Survey Design](#setup-survey-design)
-   [Create Employment Metric](#create-employment-metric)
-   [Evaluate Results](#evaluate-results)
-   [Export](#export)


## Housekeeping

Read in packages for use. If you do not have an IPUMS API key you will need to make one via the [IPUMS website](https://www.ipums.org/).

```{r}
library(tidyverse)
library(Hmisc)
library(ipumsr)
library(reactable)
library(srvyr)
library(scales)

options(scipen = 999)

#set_ipums_api_key("Your KEY", save = TRUE)
source(here::here("functions", "API", "extract_ipums.R"))
```

## Read Data

Read in the ACS extracts using the extract_ipums function. Make sure to change the survey list to reflect what years you want to include in the data. Currently we are including three years of 1-year data (2018a, 2021a and 2022a) and two years of 5-year data (2018c and 2021c). 5-year 2022 data will be added pending its release.
```{r}
acs <- extract_ipums(
  extract_name = "umf_data_18_22",
  extract_description = "Microdata pull for Mobility Metric Predictors. American Community Survey, years 2018, 2019 and 2022 (1 and 5-year).",
  survey = list("us2018a", "us2021a", "us2022a", "us2018c", "us2021c")
) 
```

Look at the distribution of ACS survey samples in the data. The number of different samples should align with the number of surveys selected in the extract ipums function.
```{r}
acs %>% 
  count(sample) %>% 
  ggplot(mapping = aes(x = sample, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Samples, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Samples",
       y = NULL)
```

Read in the PUMA to place crosswalk file. This file is created by the program generate_puma_place_crosswalks.rmd in the geographic-crosswalks folder. 
```{r}
puma_place_crosswalk <- read_csv(here::here("geographic-crosswalks", "data", "crosswalk_puma_to_place.csv"))
```

Crate a version of the crosswalk with just the place-level values of data quality variables for each crosswalk period.
```{r}
place_puma <- puma_place_crosswalk %>%
  group_by(crosswalk_period, statefip, place) %>% 
  summarise(geographic_allocation_quality = mean(geographic_allocation_quality)) %>% 
  ungroup()
```

## Clean Data

Missing data is reported in a variety of ways by IPUMS data - listed below:

Age: No missing values reported in variable description.
Empstat: N/As reported as "0".
Vacancy is reported as "0". 

There is a large share of records reported as "0" for empstat. The distribution of age looks reasonable (no bunching or extreme outliers). Note there are no vacancy results by default of the structure of census data read in.

```{r}
acs %>% 
  count(empstat) %>% 
  ggplot(mapping = aes(x = factor(empstat), y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Empstat, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Employment Status",
       y = NULL)

acs %>% 
  ggplot(aes(x = age)) +
  geom_density(color = "blue", fill = alpha("blue", 0.3)) +
  theme_minimal() +
  ggtitle("Age Variable Results") +
  ylab("Density")

acs %>% 
  ggplot(aes(x = vacancy)) +
  geom_density(color = "blue", fill = alpha("blue", 0.3)) +
  theme_minimal() +
  ggtitle("Vacancy Variable Results") +
  ylab("Density")
```

Isolate the data to 25-54 year-olds. This is the age-range included in the employment calculation.
```{r}
acs_clean <- acs %>% 
  filter(age >= 25 & age <= 54) 

rm(acs)
```

Turn the missing/"not in universe" value from the empstat variable into NAs.
```{r}
acs_clean <- acs_clean %>%
  mutate(empstat = ifelse(empstat == 0, NA_integer_,
                          empstat)
  )
```

Look at the distribution of empstat after adjustment for NAs. There should be no more records with the value "0".
```{r}
acs_clean %>% 
  count(empstat) %>% 
  ggplot(mapping = aes(x = factor(empstat), y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Empstat, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Employment Status",
       y = NULL)
```

Filter for group quarters (GQ), we want to keep only households including additional households under updated definitions.
```{r}
acs_clean %>% 
  group_by(gq) %>% 
  count()
```

```{r}
acs_clean <- acs_clean %>%
  filter(gq %in% c("Households under 1970 definition", 
                   "Additional households under 1990 definition",
                   "Additional households under 2000 definition"))
```

Check that group quarters fall only into household categories.
```{r}
acs_clean %>% 
  count(gq) %>% 
  ggplot(mapping = aes(x = gq, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("GQ, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "GQ",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

### Create race variable

Evaluate the values in the RACE and HISPAN variables.

* IPUMS documented values for RACE: 
  + 1 White
  + 2 Black/African American/Negro
  + 3 American Indian or Alaska Native 
  + 4 Chinese 
  + 5 Japanese
  + 6 Other Asian or Pacific Islander 
  + 7 Other race 
  + 8 Two major races 
  + 9 Three or more major races

* IPUMS documented values for HISPAN: 
  + 0 Not Hispanic 
  + 1 Mexican 
  + 2 Puerto Rican 
  + 3 Cuban 
  + 4 Other 
  + 9 Not Reported 

Look at the distribution of values for the race and hispan variables.
```{r}

acs_clean %>% 
  count(race) %>% 
  ggplot(mapping = aes(x = race, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Race, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Race",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

acs_clean %>% 
  count(hispan) %>% 
  ggplot(mapping = aes(x = hispan, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Hispan, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Hispan",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

Create the race/ethnicity variable. For race/ethnicity categories that are not coded as Hispanic, Hispan must be equal to "Not Hispanic". 

Rename the values from number category to race label: 
  +Race is Black/African American and Hispan is Not Hispanic = "Black, Non-Hispanic"
  +Hispan is not equal to Not Hispanic = "Hispanic"
  +Race is not Black or White and Hispan is Not Hispanic  = "Other Races and Ethnicities" 
  +Race is White and Hispan is Not Hispanic = "White, Non-Hispanic" 
```{r}

acs_clean <- acs_clean %>%
  mutate(subgroup = case_when((hispan == "Not Hispanic" & race == "White") ~ "White, Non-Hispanic",
                              (hispan == "Not Hispanic" & race == "Black/African American") ~ "Black, Non-Hispanic",
                              (hispan == "Not Hispanic" & !race %in% c("Black/African American", "White")) ~ "Other Races and Ethnicities",
                               hispan != "Not Hispanic" ~ "Hispanic"
  ))

```

Look at the subgroup distribution.
```{r}

acs_clean %>% 
  count(subgroup) %>% 
  ggplot(mapping = aes(x = factor(subgroup), y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Subgroup, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Subgroup",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

### Create gender variable

Evaluate the values in the gender variable.

* IPUMS documented values for SEX: 
  + 1 Male
  + 2 Female
  + 9 Missing/blank 

Look at the distribution of values for the sex variable. 
```{r}

acs_clean %>% 
  count(sex) %>% 
  ggplot(mapping = aes(x = sex, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("sex, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Sex",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

Create a variable for subgroup_gender from the sex variable. The titles remain the same but any values outside of Male and Female are mutated to NA character variables. 
```{r}
acs_clean <- acs_clean %>% 
  mutate(subgroup_gender = case_when(sex == "Male" ~ "Male",
                                     sex == "Female" ~ "Female",
                                     TRUE ~ NA_character_))
```

Check the variable breakout. This should be approximately 50/50.
```{r}
acs_clean %>% 
  count(subgroup_gender) %>% 
  ggplot(mapping = aes(x = subgroup_gender, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Subgroup Gender, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Gender",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

### Create disability variable

The ACS includes 5 variables covering physical and mental disabilitie (DIFFCARE, DIFFSENS, DIFFMOB, DIFFPHYS, DIFFREM).
Evaluate the values in these variables and create an overall subgroup for disability.
We will count an individual to be disabled if they answer yes or have any of these difficulties. 

* IPUMS documented values for DIFFCARE (Self-care difficulty): 
  + 0 N/A
  + 1 No
  + 2 Yes 

Plot the options for diffcare below.
```{r}

acs_clean %>% 
  count(diffcare) %>% 
  ggplot(mapping = aes(x = diffcare, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Self-care difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Diffcare",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

* IPUMS documented values for DIFFSENS (Vision or hearing difficulty): 
  + 0 N/A
  + 1 No vision or hearing difficulty
  + 2 Has vision or hearing difficulty

Plot the options for diffsens below.
```{r}

acs_clean %>% 
  count(diffsens) %>% 
  ggplot(mapping = aes(x = diffsens, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Vision or Hearing difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Diffsens",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

* IPUMS documented values for DIFFMOB (Independent living difficulty): 
  + 0 N/A
  + 1 No independent living difficulty
  + 2 Has independent living difficulty

Plot the options for diffmob below.
```{r}

acs_clean %>% 
  count(diffmob) %>% 
  ggplot(mapping = aes(x = diffmob, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Independent living difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Diffmob",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```

* IPUMS documented values for DIFFPHYS (Ambulatory difficulty): 
  + 0 N/A
  + 1 No ambulatory difficulty
  + 2 Has ambulatory difficulty 
  
Plot the options for diffphys below.
```{r}

acs_clean %>% 
  count(diffphys) %>% 
  ggplot(mapping = aes(x = diffphys, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Ambulatory difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Diffphys",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```
  
* IPUMS documented values for DIFFREM  (Cognitive difficulty): 
  + 0 N/A
  + 1 No cognitive difficulty
  + 2 Has cognitive difficulty 
  
Plot the options for diffrem below.
```{r}
acs_clean %>% 
  count(diffrem) %>% 
  ggplot(mapping = aes(x = diffrem, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Cognitive difficulty, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Diffrem",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))

```


Create the subgroup for disability. 
```{r}
acs_clean <- acs_clean %>% 
  mutate(subgroup_disability = case_when(diffrem == "Has cognitive difficulty" |
                                           diffphys == "Has ambulatory difficulty" |
                                           diffmob == "Has independent living difficulty" |
                                           diffsens == "Has vision or hearing difficulty" |
                                           diffcare == "Yes" ~ "with disabiliy",
                                         TRUE ~ "without disability"))
  
```


Check the variable breakout. 
```{r}
acs_clean %>% 
  count(subgroup_disability) %>% 
  ggplot(mapping = aes(x = subgroup_disability, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Subgroup Disability, All Records") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Disability",
       y = NULL)+
  scale_x_discrete(labels = label_wrap(10))
```

## Merge Crosswalk 

Create a variable in the ACS data indicating whether the survey year is pre or post-2022. This will be used to join on the correct crosswalk information.
```{r}
acs_clean <- acs_clean %>% 
  mutate(crosswalk_period = ifelse(year < 2022, "pre-2022", "2022"))

```

Check that the assignment worked. All years prior to 2022 should be designated "pre-2022".
```{r}
acs_clean %>% 
  group_by(crosswalk_period, year) %>% 
  count()
```

Join the cleaned ACS data onto the crosswalk. 
```{r}
acs_clean <- left_join(acs_clean, puma_place_crosswalk, by=c("crosswalk_period", "statefip","puma"), relationship = "many-to-many")
```

Run anti_join to see how many cases did not have a match in the crosswalk. We only select the largest 450 places so this number should be significant.
```{r}
anti_join(acs_clean, puma_place_crosswalk, by=c("crosswalk_period", "statefip","puma"))
```

Drop any observations with NA for afact (i.e. there is no place of interest overlapping this PUMA).
```{r}
acs_clean <- acs_clean %>% 
  drop_na(afact)
```

Also filter out cases where AFACT is equal to zero. These cases will not be counted in the metric calculation.
```{r}
acs_clean <- acs_clean %>% 
  filter(afact > 0)
```

Adjust the person weight to account for PUMA-to-place mapping (those where the PUMA is not entirely inside the place).
```{r}

acs_clean <- acs_clean %>%
  mutate(perwt = perwt*afact) 

```

Create a binary variable to distinguish between 1 and 5 year ACS data sets. 5-year samples include the term "5-year".
```{r}
acs_clean <- acs_clean %>%
  mutate(sample_structure = ifelse(str_detect(sample, "5-year"), "5year", "1year")) 
```

Isolate the data to 25-54 year-olds. This is the age-range included in the employment calculation.
```{r}
acs_clean <- acs_clean %>% 
  filter(age >= 25 & age <= 54) 
```

Create a binary employed variable indicating employed or not-employed. IPUMS data codes "Employed" as equal to 1.
```{r}
acs_clean <- acs_clean %>% 
  mutate(employed = ifelse(empstat == 1, 1, 0)) 
```

Check how many records, if any, have NA reported for empstat after filtering (this should be zero).
```{r}
acs_clean %>%
  filter(is.na(empstat)) %>% 
  group_by(pernum) %>% 
  count()
```

Confirm there are no vacant properties included in the data.

```{r}
acs_clean %>%
  filter(is.na(vacancy)) %>% 
  group_by(pernum) %>% 
  count()
```

## Read replicate weights 

Read in person-level replicate weights for the 25 to 54 year old population. These will be used in creating standard errors for the employment opportunity calculation. 
```{r}
repwts_person <- ipums_repwt_employment(
  extract_name = "employment_replicate_weights",
  extract_description = "Person replicate weights for Employment Opportunities Metric Predictors. American Community Survey, years 2018, 2019 and 2022 (1 and 5-year).",
  survey = list("us2018a", "us2021a", "us2022a", "us2018c", "us2021c")
)  %>% 
  select(-cbserial, -cbpernum)
```

Look at the distribution of ACS survey samples in the data. The number of different samples should align with the number of surveys selected in the extract ipums function.
```{r}
repwts_person %>% 
  count(sample) %>% 
  ggplot(mapping = aes(x = sample, y = n)) +
  geom_col() +
  theme_minimal() +
  ggtitle("Samples, All Records in Repwt File") +
 geom_text(mapping = aes(label = n), vjust = -1) +    
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(x = "Samples",
       y = NULL)
```

Remove the sample variable.
```{r}
repwts_person <- repwts_person %>% 
  select(-sample)
```

## Setup Survey Design 

Shrink sample for now.
```{r}
acs_clean <- acs_clean %>% 
  group_by(sample, place) %>% 
  slice_sample(n = 200) %>% 
  ungroup()

```

Set up the survey design using instructions from IPUMS. Join the replicate weights onto the acs survey data using the unique person ID created for both.
```{r}
acs_survey_all <- acs_clean %>%
  filter(sample_structure == "1year") %>% 
  left_join(repwts_person, by = c("unique_person_id")) %>% 
  as_survey_design(weights = perwt, 
                   repweights = matches("repwtp[0-9]+"),
                   type = "JK1",
                   scale = 4/ 80,
                   rscales = rep(1, 80 ), mse = TRUE) %>% 
  ungroup()

acs_survey_subgroups <- acs_clean %>%
  filter(sample_structure == "5year") %>% 
  left_join(repwts_person, by = c("unique_person_id")) %>% 
  as_survey_design(weights = perwt, 
                   repweights = matches("repwtp[0-9]+"),
                   type = "JK1",
                   scale = 4/ 80,
                   rscales = rep(1, 80 ), mse = TRUE) %>% 
  ungroup()

```

## Create employment metric

Create the employment metric. 

Objective: get the percent of individuals between the ages 25 and 54 that are employed from the EMPSTAT variable.

Aggregation should be weighted by PERWT (this is a person level statistic).

Check national employment ratio. Compute the ratio (share employed) for 2018, 2021 and 2022 nationally and show results.
```{r}
acs_survey_all %>%
  group_by(year) %>%
  summarise(
    share_employed = survey_mean(employed, vartype = "ci"),
    count = unweighted(n())
  ) %>% 
  ungroup() %>% 
  reactable()
```

### All

Create share employed for all individuals at the place-level (1-year data) using the survey_mean function.
```{r}
metrics_employment_all <- acs_survey_all %>%
  group_by(year, crosswalk_period, statefip, place) %>%
  summarise(
    share_employed = survey_mean(employed, vartype = "ci")
  ) %>% 
  ungroup()
```

Cap upper-bound confidence intervals at 100% (above would be an illogical option). If it is greater than 1, make the share equal to exactly 1.
```{r}
metrics_employment_all <- metrics_employment_all %>% 
  mutate(share_employed_upp =  ifelse(share_employed_upp > 1, 1, share_employed_upp))
```

Sort by year, state and place.
```{r}
metrics_employment_all <- metrics_employment_all %>%
  arrange(year, statefip, place)
```

*Create an indicator for data quality and suppression*

Calculate the effective sample count for each place, defined as the sum of the afact variable. This is used to create a cutoff for data quality based on the actual number of survey records being used in the calculation.
```{r}
effective_sample <- acs_clean %>%
  filter(sample_structure == "1year") %>% 
  group_by(year, crosswalk_period, statefip, place) %>%
  summarise(effective_sample = sum(afact)) %>% 
  ungroup()
```

Merge the data quality flags from place_puma and effective sample to create the final data quality metric based on both size and geographic allocation.
```{r}
metrics_employment_all <- left_join(metrics_employment_all, place_puma, by=c("crosswalk_period", "statefip","place"))

metrics_employment_all <- left_join(metrics_employment_all, effective_sample, by=c("year", "crosswalk_period", "statefip","place"))
```

Tabulate effective sample counts for each place, defined as the sum of the afact for all records in that place. Look at the distribution of counties by potential cutoffs (30, 100, 300). This is to measure data quality for each place based on the number of records reported. In the 1-year data for all there are no cases of a place with less than 100 observations for 2018, 2021 and 2022.
```{r}
reactable_data <- metrics_employment_all %>%
  mutate(
    effective_sample_cutoffs = case_when(
      effective_sample < 30 ~ "Less than 30",
      effective_sample >= 30 &
        effective_sample <= 100 ~ "Over 30 but 100 or less",
      effective_sample > 100 &
        effective_sample <= 300 ~ "Over 100 but 300 or less",
      TRUE ~ "Greater than 300"
    ),
    effective_sample_cutoffs = factor(
      effective_sample_cutoffs,
      levels = c(
        "Less than 30",
        "Over 30 but 100 or less",
        "Over 100 but 300 or less",
        "Greater than 300"
      )
    )
  ) 

# Get suppression factor for each year of data
suppression_factor <- reactable_data %>%
  group_by(year) %>%
  summarize(yearly_total = n()) %>% 
  select(year, yearly_total)

# Create reactable for further examination
reactable_data %>%
  left_join(suppression_factor, by="year") %>% 
  group_by(year,effective_sample_cutoffs) %>%
  summarize(
    n = n(), 
    suppression_share = n()/unique(yearly_total)
  ) %>% 
  # yearly value has one unique value per year %>%
  reactable()

```

Generate the quality variable for each place.
```{r}
metrics_employment_all <- metrics_employment_all %>% 
  mutate(effective_sample_flag = ifelse(effective_sample < 100, 1, 0),
         share_employed_quality = case_when(effective_sample_flag==0 & geographic_allocation_quality==1 ~ 1,
                                     effective_sample_flag==0 & geographic_allocation_quality==2 ~ 2,
                                     effective_sample_flag==0 & geographic_allocation_quality==3 ~ 3,
                                     effective_sample_flag==1 ~ 3)
  )
```

We do not want to show values that are calculated from less than 30 samples in the data. These points will be suppressed and shown as missing or NA. Suppress the results for values generated from less than 30 samples.
```{r}
metrics_employment_all <- metrics_employment_all %>% 
  mutate_at(c("share_employed", "share_employed_low", "share_employed_upp"), ~if_else(effective_sample < 30, NA_integer_, .)) 
```

Keep only relevant variables.
```{r}
metrics_employment_all <- metrics_employment_all %>%
  select(year,
         statefip,
         place,
         share_employed,
         share_employed_lb = share_employed_low,
         share_employed_ub = share_employed_upp,
         share_employed_quality)
```


### Subgroup

Create share employed by race/ethnicity at the place-level (5-year data) using the survey_mean function.
```{r}
metrics_employment_subgroup_race <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, place, subgroup_race) %>%
  summarise(
    share_employed = survey_mean(employed, vartype = "ci")
  ) %>% 
  ungroup() %>%
  mutate(subgroup_type = "race-ethnicity") %>% 
  rename(subgroup = subgroup_race)
```

Create share employed by gender at the place-level (5-year data) using the survey_mean function.
```{r}
metrics_employment_subgroup_gender <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, place, subgroup_gender) %>%
  summarise(
    share_employed = survey_mean(employed, vartype = "ci")
  ) %>% 
  ungroup() %>%
  mutate(subgroup_type = "gender") %>% 
  rename(subgroup = subgroup_race)
```

Create share employed by disability at the place-level (5-year data) using the survey_mean function.
```{r}
metrics_employment_subgroup_disability <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, place, subgroup_disability) %>%
  summarise(
    share_employed = survey_mean(employed, vartype = "ci")
  ) %>% 
  ungroup() %>%
  mutate(subgroup_type = "disability") %>% 
  rename(subgroup = subgroup_race)
```

Create the share employed measure for all values in the 5-year data (non-subgroup). This will be merged onto the subgroup data. 
```{r}
metrics_employment_subgroup_all <- acs_survey_subgroups %>%
  group_by(year, crosswalk_period, statefip, place) %>%
  summarise(
    share_employed = survey_mean(employed, vartype = "ci")
  ) %>% 
  ungroup() %>%
  mutate(subgroup_type = "all",
         subgroup = "All")
```

Append the "All" version of the data.
```{r}
metrics_employment_sub <- bind_rows(metrics_employment_subgroup_race, metrics_employment_subgroup_gender, metrics_employment_subgroup_disability, metrics_employment_subgroup_all)
```

Check that all subgroup types are included. We should see all, disability, gender and race-ethnicity.
```{r}
metrics_employment_sub %>% 
  group_by(subgroup_type) %>% 
  count()
```

Cap upper-bound confidence intervals at 100% (above would be an illogical option). If it is greater than 1, make the share equal to exactly 1.
```{r}
metrics_employment_sub <- metrics_employment_sub %>% 
  mutate(share_employed_upp =  ifelse(share_employed_upp > 1, 1, share_employed_upp))
```

Sort by place again to double check we have 5 observations per place (All, Black, White, Hispanic, Other).
```{r}
metrics_employment_sub <- metrics_employment_sub %>%
  arrange(year, statefip, place)
```

*Create an indicator for data quality and suppression*

Calculate the effective sample count for each subgroup in all counties as well as for all records in every place in the 5-year data.
```{r}
effective_sample_sub_all <- acs_clean %>%
  filter(sample_structure == "5year") %>% 
  group_by(year, crosswalk_period, statefip, place) %>%
  summarise(effective_sample = sum(afact)) %>% 
  mutate(subgroup_type = "all",
         subgroup = "All")

effective_sample_race <- acs_clean %>%
  filter(sample_structure == "5year") %>% 
  group_by(year, crosswalk_period, statefip, place, subgroup_race) %>%
  summarise(effective_sample = sum(afact)) %>% 
  mutate(subgroup_type = "race-ethnicity") %>% 
  rename(subgroup = subgroup_race)

effective_sample_gender <- acs_clean %>%
  filter(sample_structure == "5year") %>% 
  group_by(year, crosswalk_period, statefip, place, subgroup_gender) %>%
  summarise(effective_sample = sum(afact)) %>% 
  mutate(subgroup_type = "gender") %>% 
  rename(subgroup = subgroup_gender)

effective_sample_sub <- acs_clean %>%
  filter(sample_structure == "5year") %>% 
  group_by(year, crosswalk_period, statefip, place, subgroup_disability) %>%
  summarise(effective_sample = sum(afact)) %>% 
  mutate(subgroup_type = "disability") %>% 
  rename(subgroup = subgroup_disability) %>% 
  bind_rows(effective_sample_sub_all, effective_sample_race, effective_sample_gender) %>% 
  ungroup()
```

Merge the data quality flags from place_puma and effective sample to create the final data quality metric based on both size and geographic allocation.
```{r}
metrics_employment_sub <- left_join(metrics_employment_sub, place_puma, by=c("crosswalk_period", "statefip","place"))

metrics_employment_sub <- left_join(metrics_employment_sub, effective_sample_sub, by=c("year", "crosswalk_period", "statefip","place", "subgroup_type", "subgroup"))
```

Tabulate effective sample counts for each place by sugroup, defined as the sum of the afact for all records in that place. Look at the distribution of counties by potential cutoffs (30, 100, 300). This is to measure data quality for each place based on the number of records reported. 
```{r}
reactable_data <- metrics_employment_sub %>%
  mutate(
    effective_sample_cutoffs = case_when(
      effective_sample < 30 ~ "Less than 30",
      effective_sample >= 30 &
        effective_sample <= 100 ~ "Over 30 but 100 or less",
      effective_sample > 100 &
        effective_sample <= 300 ~ "Over 100 but 300 or less",
      TRUE ~ "Greater than 300"
    ),
    effective_sample_cutoffs = factor(
      effective_sample_cutoffs,
      levels = c(
        "Less than 30",
        "Over 30 but 100 or less",
        "Over 100 but 300 or less",
        "Greater than 300"
      )
    )
  ) 

# Create reactable for further examination using suppression factor defined earlier
reactable_data %>%
  left_join(suppression_factor, by="year") %>% 
  group_by(year,subgroup,effective_sample_cutoffs) %>%
  summarize(
    n = n(), 
    suppression_share = n() / unique(yearly_total)
  ) %>% 
  # yearly value has one unique value per year %>%
  reactable()
```

Generate the quality variable for each place.
```{r}
metrics_employment_sub <- metrics_employment_sub %>% 
  mutate(effective_sample_flag = ifelse(effective_sample < 100, 1, 0),
         share_employed_quality = case_when(effective_sample_flag==0 & geographic_allocation_quality==1 ~ 1,
                                     effective_sample_flag==0 & geographic_allocation_quality==2 ~ 2,
                                     effective_sample_flag==0 & geographic_allocation_quality==3 ~ 3,
                                     effective_sample_flag==1 ~ 3)
  )
```

We do not want to show values that are calculated from less than 30 samples in the data. These points will be suppressed and shown as missing or NA. Suppress the results for values generated from less than 30 samples.
```{r}
metrics_employment_sub <- metrics_employment_sub %>% 
  mutate_at(c("share_employed", "share_employed_low", "share_employed_upp"), ~if_else(effective_sample < 30, NA_integer_, .)) 
```

Keep only relevant variables.
```{r}

metrics_employment_sub <- metrics_employment_sub %>%
  select(year,
         statefip,
         place,
         subgroup_type, 
         subgroup,
         share_employed,
         share_employed_lb = share_employed_low,
         share_employed_ub = share_employed_upp,
         share_employed_quality)

```

### Evaluate results

Summarize the predictors for the 1-year and 5-year data.
```{r}
metrics_employment_all %>% 
  select(share_employed:share_employed_quality) %>% 
  summary()

metrics_employment_sub %>% 
  select(share_employed:share_employed_quality) %>% 
  summary()
```


Look at distribution of employment share by place.
```{r}

metrics_employment_all %>% 
  filter(year == 2022) %>% 
  select(share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("Distribution of share employed, by place 2022 (1-year data)") +
  ylab("Density")

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "All") %>% 
  select(share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("Distribution of share employed, by place 2022 (5-year data)") +
  ylab("Density")
  
```

### Race distribution
Look at distribution of hs_degree share by place by race.
```{r}

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "Black, Non-Hispanic") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, Black") +
  ylab("Density")

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "Hispanic") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, Hispanic") +
  ylab("Density")

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "Other Races and Ethnicities") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, Other Races and Ethnicities") +
  ylab("Density")

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "White, Non-Hispanic") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, White, Non-Hispanic") +
  ylab("Density")

```

### Gender distribution
Look at distribution of hs_degree share by place by gender.
```{r}
metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "Male") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, males") +
  ylab("Density")

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "Female") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, females") +
  ylab("Density")
```

### Disability distribution
Look at distribution of hs_degree share by place by disability status.
```{r}

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "with disabiliy") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, with disabilities") +
  ylab("Density")

metrics_employment_sub %>% 
  filter(year == 2021, subgroup == "without disability") %>% 
  select(place, share_employed) %>% 
  ggplot(aes(x = share_employed)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("hs_degree Share, without disabilities") +
  ylab("Density")

```
Look at the counts of the quality flag.
```{r}
metrics_employment_all %>% 
  select(share_employed_quality) %>% 
  ggplot(aes(x = share_employed_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  ggtitle("Quality Flag (1-year data)") +
  ylab("Count")

metrics_employment_sub %>% 
  select(share_employed_quality) %>% 
  ggplot(aes(x = share_employed_quality)) +
  geom_histogram(color = "blue", fill = alpha("blue", 0.3), binwidth = 1.0) +
  theme_minimal() +
  ggtitle("Quality Flag (5-year data") +
  ylab("Count")
```

Tabulate share of data suppressed by year.
```{r}
metrics_employment_all %>% 
  group_by(year) %>% 
  filter(is.na(share_employed)) %>% 
  count()

metrics_employment_sub %>% 
  group_by(year) %>% 
  filter(is.na(share_employed)) %>% 
  count()
```

## Export 

Rename state.
```{r}
metrics_employment_all <- metrics_employment_all %>% 
  rename("state" = "statefip")

metrics_employment_sub <- metrics_employment_sub %>% 
  rename("state" = "statefip")
```

Order the variables how we want.
```{r}
metrics_employment_all <- metrics_employment_all %>% 
  select(year, state, place, share_employed, share_employed_lb,
         share_employed_ub, share_employed_quality)

metrics_employment_sub <- metrics_employment_sub %>% 
  select(year, state, place, subgroup_type, subgroup, share_employed, share_employed, share_employed_lb, share_employed_ub, share_employed_quality)
```
Export as CSV

```{r}
write_csv(metrics_employment_all, here::here("09_employment", "data", "final", "metrics_employment_place_all_longitudinal.csv"))
write_csv(metrics_employment_sub, here::here("09_employment", "data", "final", "metrics_employment_place_race-ethnicity_longitudinal.csv"))
```





