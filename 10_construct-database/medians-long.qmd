---
title: "Calculate Medians for Dashboard - Longitudinal"
author: "Aaron R. Williams"
date: today
format:
  html:
    df-print: kable
    toc: true
    toc_float: true
    embed-resources: true
execute: 
  warning: false
editor_options: 
  chunk_output_type: console
---

# Mobility metrics median calculations

This code calculates weighted medians of the mobility metrics at the county and then the place level.

We exclude missing values and calculate the proportion of places and proportion of population missing for each metric. The function below is used to calculate the proportion of population missing for each metric.

```{r}
missing_share <- function(x, weight) {
  
  sum(as.numeric(is.na(x)) * weight) / sum(weight)
  
}
```


The steps taken for calculating the median estimates are as follow:

-   Calculate the population-weighted median
-   Calculate the proportion of places that are missing
-   Calculate the proportion of people that are missing

# County level

## Load Packages

```{r}
#| label: load-packages

options(scipen = 999)

library(tidyverse)
library(here)
library(tidycensus)
library(kableExtra)

```

## Load Data

```{r}
#| label: load-data
metrics <- read_csv(here("data", "00_mobility-metrics_longitudinal.csv")) |>
  select(-ends_with("_lb"), -ends_with("_ub"))

# Create crosswalk for each variable's corresponding quality field
metric_qual_crosswalk <- as_tibble(
  metrics |> 
  select((where(is.numeric) & !matches('quality')) | index_air_quality) |> 
  colnames()
) |> 
  rename(name = value) |> 
  mutate(qual_varname = case_when(
    str_detect(name, 'pctl_income') ~ 'pctl_income_quality',
    str_detect(name, 'share_affordable') ~ 'share_affordable_quality',
    str_detect(name, 'homeless') ~ 'homeless_quality',
    str_detect(name, 'crime') ~ 'rate_crime_quality',
    str_detect(name, 'share_desc_rep') ~ NA, # No quality variables for these
    TRUE ~ str_c(name, '_quality')
  ))
```

We load county-level population estimates from the 2020 decennial census.

```{r}
# Not available for 2014 so set that year equal to 2015 values
population <- map_dfr(c(2015, 2015:2022), ~get_estimates(
  geography = "county", 
  product = "population",
  year = .x
),
.id = 'year') |>
  filter(variable %in% c('POP', 'POPESTIMATE')) |> 
  mutate(
    year = as.numeric(year) + 2013,
    state = str_sub(GEOID, start = 1, end = 2),
    county = str_sub(GEOID, start = 3, end = 5)
  ) |>
  select(state, county, population = value, year)

metrics <- left_join(metrics, population, by = c("state", "county", "year"))

sum(is.na(metrics$population))

```

## Calculate Medians

We calculate weighted medians for each numeric variable. This means our estimates represent the county mobility metric for the average American.

```{r}
# Remove missing variable-year combos
safe_wtd_quantile <- possibly(Hmisc::wtd.quantile, otherwise = NA)
weighted_median <- metrics |>
  select(where(is.numeric) & (!ends_with('quality') | index_air_quality)) |> 
  summarize(
    across(
      .cols = -population, 
      .fns = ~safe_wtd_quantile(., weights = population, probs = 0.5, na.rm = TRUE)
    ), .by = 'year'
  ) |>
  pivot_longer(cols = -year, values_to = "weighted_median")

state_count <- metrics |> 
  pivot_longer(cols = ends_with('_quality') & -index_air_quality, names_to = 'qual_varname', values_to = 'quality') |> 
  filter(quality %in% 1:2) |> 
  count(state_name, year, qual_varname) |> 
  count(qual_varname, year, name = 'n_states')
  
proportion_by_qual <- metrics |>
  select(where(is.numeric)) |>
  pivot_longer(cols = ends_with('_quality') & -index_air_quality, names_to = 'qual_varname', values_to = 'quality') |> 
  summarize(population = sum(population),
   .by = c('year', 'qual_varname', 'quality')
  ) |> 
  mutate(pop_share = population / sum(population), .by = c('year', 'qual_varname')) |> 
  filter(quality %in% 2:3) |> 
  select(-population) |> 
  arrange(qual_varname, quality)


missing_population <- metrics |>
  select(where(is.numeric) & (!ends_with('quality') | index_air_quality)) |>
  summarize(
    across(
      .cols = -population, 
      .fns = ~missing_share(.x, weight = population)
    ), .by='year') |> 
  pivot_longer(cols = -year, values_to = "missing_population")
 
missing_county <- metrics |>
  select(where(is.numeric) & (!ends_with('quality') | index_air_quality)) |>
  summarize(
    across(
      .cols = -population, 
      .fns = ~sum(is.na(.x)) / n()
    ), .by = 'year') |> 
  pivot_longer(cols = -year, values_to = "missing_county")
  
weighted_median |> 
  full_join(missing_population, by = c("year", "name")) |>
  full_join(missing_county, by = c("year", "name")) |>
  left_join(metric_qual_crosswalk, by = "name") |> 
  left_join(proportion_by_qual, by = c("year", "qual_varname")) |>  #M:M Merge is expected behavior here
  left_join(state_count, by = c("year", "qual_varname")) |> 
  pivot_wider(names_from = quality, names_glue = 'quality{quality}_popshare', values_from = pop_share) |>
  select(-qual_varname, -qualityNA_popshare) |> 
  mutate(across(where(is.numeric), ~round(.,digits=2))) |> 
  rowwise() |> 
  # Share of pop that is either missing or quality = 3 for that metric
  mutate(share_lq3 = sum(missing_population, quality3_popshare, na.rm = TRUE)) |> 
  # Remove all-missing metric-years
  filter(missing_county < 1) |> 
  kbl() |> 
  kable_styling(font_size = 10, fixed_thead = TRUE)


```

# Place level

This section of the code calculates variable medians at the place level.

## Load Data

```{r}
#| label: load-data-place
metrics <- read_csv(here("data", "05_mobility-metrics_place_longitudinal.csv")) |>
  select(-ends_with("_lb"), -ends_with("_ub"))

```

We load place-level population estimates from the 2020 decennial census.

```{r}
get_estimates_place <- function(year){
  if(year < 2020) variable = "POP"
  else variable = "POPESTIMATE"
  get_estimates(year = year, 
                geography = 'place',
                variable = variable)
}
population <- map_dfr(c(2015, 2015:2022), ~get_estimates_place(year = .x), .id = 'year') |>
  filter(variable %in% c('POP', 'POPESTIMATE')) |> 
  mutate(
    year = as.numeric(year) + 2013,
    state = str_sub(GEOID, start = 1, end = 2),
    place = str_sub(GEOID, start = 3, end = 7)
  ) |>
  select(state, place, population = value, year)

metrics <- left_join(metrics, population, by = c("state", "place", "year"))
```

## Calculate Medians

We calculate weighted medians for each numeric variable. This means our estimates represent the place mobility metric for the average American living in a large city.

```{r}
weighted_median <- metrics |>
  select(where(is.numeric) & (!ends_with('quality') | index_air_quality)) |> 
  summarize(
    across(
      .cols = -population, 
      .fns = ~safe_wtd_quantile(., weights = population, probs = 0.5, na.rm = TRUE)
    ), .by = 'year'
  ) |>
  pivot_longer(cols = -year, values_to = "weighted_median")

state_count <- metrics |> 
  pivot_longer(cols = ends_with('_quality') & -index_air_quality, names_to = 'qual_varname', values_to = 'quality') |> 
  filter(quality %in% 1:2) |> 
  count(state_name, year, qual_varname) |> 
  count(qual_varname, year, name = 'n_states')
  
proportion_by_qual <- metrics |>
  select(where(is.numeric)) |>
  pivot_longer(cols = ends_with('_quality') & -index_air_quality, names_to = 'qual_varname', values_to = 'quality') |> 
  summarize(population = sum(population),
   .by = c('year', 'qual_varname', 'quality')
  ) |> 
  mutate(pop_share = population / sum(population), .by = c('year', 'qual_varname')) |> 
  filter(quality %in% 2:3) |> 
  select(-population) |> 
  arrange(qual_varname, quality)


missing_population <- metrics |>
  select(where(is.numeric) & (!ends_with('quality') | index_air_quality)) |>
  summarize(
    across(
      .cols = -population, 
      .fns = ~missing_share(.x, weight = population)
    ), .by='year') |> 
  pivot_longer(cols = -year, values_to = "missing_population")
 
missing_place <- metrics |>
  select(where(is.numeric) & (!ends_with('quality') | index_air_quality)) |>
  summarize(
    across(
      .cols = -population, 
      .fns = ~sum(is.na(.x)) / n()
    ), .by = 'year') |> 
  pivot_longer(cols = -year, values_to = "missing_place")
  
weighted_median |> 
  full_join(missing_population, by = c("year", "name")) |>
  full_join(missing_place, by = c("year", "name")) |>
  left_join(metric_qual_crosswalk, by = "name") |> 
  left_join(proportion_by_qual, by = c("year", "qual_varname")) |>  #M:M Merge is expected behavior here
  left_join(state_count, by = c("year", "qual_varname")) |> 
  pivot_wider(names_from = quality, names_glue = 'quality{quality}_popshare', values_from = pop_share) |>
  select(-qual_varname, -qualityNA_popshare) |> 
  mutate(across(where(is.numeric), ~round(.,digits=2))) |> 
  rowwise() |> 
  # Share of pop that is either missing or quality = 3 for that metric
  mutate(share_lq3 = sum(missing_population, quality3_popshare, na.rm = TRUE)) |> 
  # Remove all-missing metric-years
  filter(missing_place < 1) |> 
  kbl() |> 
  kable_styling(font_size = 10, fixed_thead = TRUE)

```

There is a high share of debt in collections missing at place level in the final data set - this is not an issue with the join.

```{r}

metrics_check <- read_csv(here("data", "05_mobility-metrics_place_recent.csv")) |>
  select(-ends_with("_quality"), -ends_with("_lb"), -ends_with("_ub"))

sum(is.na(metrics_check$share_debt_col))
```

The distribution of population for places missing the debt in collections variable is skewed to the right where the missing distribution for juvenile arrests closely reflects the general population distribution.

```{r}

#| echo: false
metrics %>%
  mutate(
    pop_missing_debt = ifelse(is.na(share_debt_col), NA_integer_, population),
    pop_missing_juv = ifelse(is.na(rate_juv_arrest), NA_integer_, population)
  ) %>%
  select(place_name, population, pop_missing_debt) %>%
  pivot_longer(-place_name, names_to = "pop_vars", values_to = "count") %>%
  ggplot(aes(x = count, color = pop_vars, fill = pop_vars)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle(
    "Comparison of distriubtions of population for all plcaes versus those missing share of debt in collections"
  )

metrics %>%
  mutate(
    pop_missing_debt = ifelse(is.na(share_debt_col), NA_integer_, population),
    pop_missing_juv = ifelse(is.na(rate_juv_arrest), NA_integer_, population)
  ) %>%
  select(place_name, population, pop_missing_juv) %>%
  pivot_longer(-place_name, names_to = "pop_vars", values_to = "count") %>%
  ggplot(aes(x = count, color = pop_vars, fill = pop_vars)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle(
    "Comparison of distriubtions of population for all plcaes versus those missing rate_juv_arrest"
  )

```
