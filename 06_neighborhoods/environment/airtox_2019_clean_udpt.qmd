---
title: "Air quality program"
author: "JP Walsh"
format: html
editor: visual
---

*Program for the creation of the Air Quality Indicator metric*

ACS Code: Initially written by Rebecca Marx and updated by JP Walsh 2022-2023.

Primary data derived from the EPA AirTox Screen Assessment.

-   [Housekeeping](#housekeeping)
-   [Program Overview](#program-overview)
-   [Read Data](#read-data)
-   [Clean Data](#clean-data)
-   [Create AirTox Metric](#create-airtox-metric)
-   [Evaluate Results](#evaluate-results)
-   [Create standard errors](#create-standard-errors)
-   [Export](#export)

## Housekeeping {#housekeeping}

Read in packages for use. If you do not have an IPUMS API key you will need to make one via the [IPUMS website](https://www.ipums.org/).

```{r, results='hide'}

library(tidycensus)
library(tidyverse)
library(tm)
library(skimr)
library(rvest)
library(httr)
library(readxl)
library(tidylog)
library(reactable)
library(janitor)

#Enter census API key here.
#census_api_key(YOUR KEY)

options(scipen = 999)
```

## Program Overview {#program-overview}

Original data pulled from:

[2019 Data](https://www.epa.gov/AirToxScreen/2019-airtoxscreen-assessment-results#nationwide) [2018 Data](https://www.epa.gov/AirToxScreen/2018-airtoxscreen-assessment-results#nationwide) [2014 Data](https://www.epa.gov/national-air-toxics-assessment/2014-nata-assessment-results)

Downloaded data is available in the Air Quality folder inside the Metrics_2024_round [box folder](https://urbanorg.box.com/s/n82wl2bv8n2nmrdcgwa07q1dyn5bldvc).

Description:

This code updates the program titled AirTox_2018_clean.R which was written by Rebecca Marx and was last updated April 4, 2023. The program recreates Rebecca's steps and adds environmental hazards data for 2019. Note that the census tracts included by the EPA in the 2018 and 2019 data are exactly the same.

Steps: (1) Add & create tract level indicators of environmental hazards for 2019 (2) create tract level indicators of environmental hazards for 2018 (3) create tract level indicators of environmental hazards for 2014 (4) compare to affh data previously used for the environmental indicator Create county files (5) population weight tract-level environmental indicators using poverty and race-identity subgroups for 2018 (6) create county level environmental index by race-identity and poverty-level for 2018 (7) population weight tract-level environmental indicators using poverty and race-identity subgroups for 2018 (8) create county level environmental index by race-identity and poverty-level for 2018 (9) population weight tract-level environmental indicators using poverty and race-identity subgroups for 2014 (10) create county level environmental index by race-identity and poverty-level for 2014 (11) bind 2019, 2018 and 2014 county files for final files

Create place files (12) prep city crosswalk data from geocorr (13) create place-level environmental indicators using poverty and race-identity subgroups for 2019 and percent of tract in place (14) create place-level environmental indicators using poverty and race-identity subgroups for 2018 and percent of tract in place (15) create place-level environmental indicators using poverty and race-identity subgroups for 2014 and percent of tract in place (16) bind 2018 and 2014 place files for final files (17) all files should be saved to mobility-from-poverty/06_neighborhoods/environment/data/output

## Read data {#read-data}

Import AirToxScreen Data on cancer, neuroligical and respitory health for years 2014, 2018 and 2019.

```{r}
airtox_data19 <- map_df(list.files(here::here("06_neighborhoods/environment/data/raw/2019/")), 
~read_excel(paste0(here::here("06_neighborhoods/environment/data/raw/2019"), "/", .x))) %>% 
  clean_names() %>% 
  mutate(year = 2019)
  
airtox_data18 <- map_df(list.files(here::here("06_neighborhoods/environment/data/raw/2018/")), 
~read_excel(paste0(here::here("06_neighborhoods/environment/data/raw/2018"), "/", .x))) %>%  
  clean_names() %>% 
  mutate(year = 2018)

airtox_data14 <- map_df(list.files(here::here("06_neighborhoods/environment/data/raw/2014/")), 
~read_excel(paste0(here::here("06_neighborhoods/environment/data/raw/2014"), "/", .x))) %>% 
  clean_names() %>% 
  mutate(year = 2014)
```

Select only the tract ID and tract level risk indicator from reach dataset.

Combine the years by variable of interest. First select only cases where total_cancer_risk is filled in and join they years.

```{r}
cancer_data <- bind_rows(airtox_data19 %>% filter(!is.na(total_cancer_risk_per_million)), 
                               airtox_data18 %>% filter(!is.na(total_cancer_risk_per_million)),
                         airtox_data14 %>% filter(!is.na(total_cancer_risk_per_million))) %>% 
  select(year, tract, total_cancer_risk_per_million)
```

Next, select only cases where total_neurological_hazard is filled in and join they years.

```{r}
nuero_data <- bind_rows(airtox_data19 %>% filter(!is.na(total_neurological_hazard_quotient)), 
                               airtox_data18 %>% filter(!is.na(total_neurological_hazard_quotient)),
                         airtox_data14 %>% filter(!is.na(total_neurological_hazard_quotient))) %>% 
  select(year, tract, total_neurological_hazard_quotient)
```

Next, select only cases where total_respiratory_hazard is filled in and join they years.

```{r}

resp_data <- bind_rows(airtox_data19 %>% filter(!is.na(total_respiratory_hazard_quotient)), 
                               airtox_data18 %>% filter(!is.na(total_respiratory_hazard_quotient)),
                         airtox_data14 %>% filter(!is.na(total_respiratory_hazard_quotient))) %>% 
  select(year, tract, total_respiratory_hazard_quotient)
```

Join the datasets by census tract. Rename the variables so they are easily refered to throughout the program.

```{r}

enviro_all <- left_join(cancer_data, nuero_data, by = c("tract", "year")) %>%
  left_join(resp_data, by = c("tract", "year")) %>% 
  select(year, tract, resp = total_respiratory_hazard_quotient, canc = total_cancer_risk_per_million,
         neuro = total_neurological_hazard_quotient)

```

## Clean Data {#clean-data}

Create a variable with just the tract GEOID information alone.

```{r}
enviro_all_clean <- enviro_all %>% 
  mutate(tract_id = str_sub(tract, start = 6, end = 11))
```

The tract variable contains some results that are not tracts. These rows can be identified because the tract GEOID will be entirely zeros. Count the number of these rows.

```{r}
enviro_all_clean %>% 
  filter(tract_id == "000000") %>% 
  group_by(tract_id) %>% 
  count()
```

Remove these rows from the data.

```{r}
enviro_all_clean <- enviro_all_clean %>% 
  filter(tract_id  != "000000")
```

Confirm there are no non-tract level rows remaining.

```{r}
enviro_all_clean %>% 
  filter(tract_id == "000000") %>% 
  group_by(tract_id) %>% 
  count()
```

## Create AirTox Metric {#create-airtox-metric}

Create variables with the mean and standard deviation of each health metric for each year.

```{r}

enviro_all_clean <- enviro_all_clean %>% 
  group_by(year) %>% 
  mutate(resp_mean = mean(resp, na.rm = TRUE),
         canc_mean = mean(canc, na.rm = TRUE),
         neuro_mean = mean(neuro, na.rm = TRUE),
         resp_stdv = sd(resp, na.rm = TRUE),
         canc_stdv = sd(canc, na.rm = TRUE),
         neuro_stdv = sd(neuro, na.rm = TRUE)) %>% 
  ungroup()

```

Add a visual on the existing variables.

```{r}


```

Create the Environmental Health Indicator using the statistics calculated above. First calcualte the components, which is the individual health indicator for a tract minus the mean of that indicator and divided by the standard deviation.

```{r}

enviro_all_clean <- enviro_all_clean %>%
  mutate(resp_norm = (resp - resp_mean)/resp_stdv,
         canc_norm = (canc - canc_mean)/canc_stdv,
         neuro_norm = (neuro - neuro_mean)/neuro_stdv)

```

Add together the normalized results and multiple by negative 1 to create the index.

```{r}
enviro_all_clean <-enviro_all_clean %>%
  mutate(envhealth = (resp_norm + canc_norm + neuro_norm)*-1)
```

Percent rank the calculated value, again grouping by year.

```{r}
enviro_all_clean <- enviro_all_clean %>%
  group_by(year) %>% 
  mutate(index_air_quality = round(percent_rank(envhealth) * 100, 0)) %>% 
  ungroup()
```

Keep only the tract and hazard index variable.

```{r}

haz_index_all <- enviro_all_clean %>% 
  select(year, tract, index_air_quality)

```

Visualize the distribution to see how it looks.

```{r}

haz_index_all %>% 
  mutate(year = factor(year)) %>% 
  ggplot(aes(x = index_air_quality, color = year, fill = year)) +
  geom_density(alpha = 0.15) +
  theme_minimal() +
  ggtitle("Tracts by air quality index, distriubtion") +
  ylab("Density")

```

### Subgroup information

Add tract-level subgroup information which breaks out the racial composition of the census tract. First we will read in tract level population data. Total population and total white, non-Hispanic. Then total population in poverty.

```{r}
load_variables(2019, "acs5", cache = TRUE) %>% 
  filter(name %in% c("B02001_001", "B03002_003", "B17001_001", "B17001_002")) %>% 
  reactable()
```


```{r}
state_abrv <- state.abb

pull_acs <- function(years) {
  
  tidycensus::get_acs(geography = "tract", 
                      variables = c("total_pop" = "B02001_001",
                                    "wnh" = "B03002_003", 
                                    "total_pop_pov" = "B17001_001", 
                                    "poverty" = "B17001_002"),
                      year = years,
                      state = state_abrv,
                      geometry = FALSE,
                      output = "wide"
  ) %>% 
    mutate(year = years)
}

acs_tracts <- map_dfr(list(2019, 2018, 2014), pull_acs)

```
Check if poverty is the same as total pop from the race category. The median difference is 15 and average difference is 108, though there are some large differences. It makes sense to use the total from the poverty variable as the denominator fot the poverty indicator. 
```{r}
acs_tracts %>% 
  mutate(population_diff = abs(total_popE - total_pop_povE)) %>% 
  arrange(desc(population_diff)) %>% 
  select(NAME, year, total_popE, total_pop_povE, population_diff) %>% 
  summary()
```


Use ACS data to create a variable for percent POC and percent in poverty, by tract.Remove the estimate indicator from value names.

```{r}
acs_tracts <- acs_tracts %>%
  select(year, geoid = GEOID,
            total_pop = total_popE,
            wnh = wnhE,
          total_pop_pov = total_pop_povE, 
            poverty = povertyE) %>% 
  mutate(poc = total_pop - wnh,
         percent_poc = poc/total_pop,
         percent_pov = poverty / total_pop_pov)
```

Create indicator variable for race based on percentage of poc/nh-White in each tract. These percentage cut offs were determined by Marge Turner. Also create indicator for tracts in 'High Poverty', with 40% or higher poverty rate meaning the tract has a high level of poverty

```{r}

race_pov <- acs_tracts %>%
  mutate(
    race_ind = case_when(
      percent_poc > .4 & percent_poc < .6 ~"No Majority Race/Ethnicity",
      percent_poc >= .6 ~ "Majority Non-White",
      percent_poc <= .6 ~ "Majority White, Non-Hispanic"), 
    poverty_type = case_when(
      percent_pov < .4 ~ "Not High Poverty",
      percent_pov >=  .4 ~ "High Poverty")
  ) %>% 
  select(year, geoid, race_ind, poverty_type, total_pop)

```

## Crosswalk to County

Crosswalk the individual years of data onto their respective county crosswalk files taken from the geographic-crosswalks folder to confirm that all counties in the main UMF data set are present in the final data. Note that the EPA did not change which counties are included between 2018 and 2019.

Read in county crosswalk and create tract level variable that combines state, county and tract IDs.

```{r}
crosswalk_cnty <- read_csv(here::here("geographic-crosswalks/data", "tract-county-crosswalk_2018.csv")) %>% 
  mutate(year1 = 2019,
         year2 = 2018,
         year3 = 2014,
         tract = paste0(state, county, tract)) %>% 
  select(tract, year1:year3) %>% 
  pivot_longer(!tract, values_to = "year", names_to = "value") %>% 
  select(-value)
```

The EPA AirToxScreen data uses some census tracts from 2010 that have been changed since then. In order to link to counties we have to adjust these tracts manually first.

```{r}

haz_index_all <- haz_index_all %>% 
  mutate(tract = case_when(                                  
      tract ==  "36053940101" ~ "36053030101",
      tract ==  "36053940102" ~ "36053030102",
      tract ==  "36053940103" ~ "36053030103", 
      tract ==  "36053940200" ~ "36053030200",
      tract ==  "36053940300" ~ "36053030300",
      tract ==  "36053940401" ~ "36053030401",
      tract ==  "36053940700" ~ "36053030402",
      tract ==  "36053940403" ~ "36053030403",
      tract ==  "36053940600" ~ "36053030600",
      tract ==  "36065940100" ~ "36065024700",
      tract ==  "36065940000" ~ "36065024800",
      tract ==  "36065940200" ~ "36065024900",
      tract ==  "04019002701" ~ "04019002704",
      tract ==  "04019002903" ~ "04019002906",
      tract ==  "04019410501" ~ "04019004118", 
      tract ==  "04019410502" ~ "04019004121",
      tract ==  "04019410503" ~ "04019004125", 
      tract ==  "04019470400" ~ "04019005200", 
      tract ==  "04019470500" ~ "04019005300", 
      tract ==  "06037930401" ~ "06037137000",
      tract ==  "51515050100" ~ "51019050100",
      tract ==  "02270000100" ~ "02158000100",
      tract ==  "46113940500" ~ "46102940500",
      tract ==  "46113940800" ~ "46102940800",
      tract ==  "46113940900" ~ "46102940900", 
      TRUE ~ tract
    ))


```

Remove results form Puerto Rico and Virgin Islands.

```{r}

haz_index_all <- haz_index_all %>%
    mutate(state = str_sub(tract, 1, 2)) %>%
  filter(state != 72 & state != 78) %>%
  select(year, tract, index_air_quality)

```

Merge the 2019 index data onto the country crosswalk file. Note that there are 531 tracts that do not have air quality data.

```{r}

haz_index_county <- crosswalk_cnty %>% 
  left_join(haz_index_all, by = c("tract", "year"))

```

Looking at the missing tracts in the crosswalk file, the states with the most missing are very large.

```{r}
anti_join(crosswalk_cnty, haz_index_all, by = "tract") %>% 
  mutate(state = str_sub(tract, start = 1, end = 2)) %>% 
  group_by(state, year) %>%
  count() %>% 
  arrange(desc(n))

```

Create state and county indicator for 2019 data

```{r}

#split tract into state and county 
haz_index_county <- haz_index_county %>%
  mutate(geoid = str_sub(tract, start = 1, end = 11),
         state = str_sub(tract, start = 1, end = 2),
         county = str_sub(tract, start = 3, end = 5)
         )


```

## Create AriTox Index Metric

### All

Join onto the environmental hazard index data. Calculate the total population for tracts where the index data is missing.

```{r}
haz_index_county_acs <- haz_index_county %>% 
  left_join(race_pov, by=c("geoid", "year")) %>% 
  mutate(na_pop= if_else(is.na(index_air_quality), total_pop, 0))
```

Calculate the average of county level hazard index for each year. Weight the mean by the total population inside each tract the value is coming from.

```{r}

haz_index_county_all <- haz_index_county_acs %>%
  group_by(year, state, county) %>%
  summarise(index_air_quality = weighted.mean(index_air_quality, total_pop, na.rm = TRUE), 
            na_pop = sum(na_pop),
            county_pop = sum(total_pop)) %>%
  ungroup()

```

Calculate percent population of each county that has missing tract hazard information.

```{r}
haz_index_county_all <- haz_index_county_all %>%
  mutate(na_perc = na_pop / county_pop,
         subgroup = "All",
         subgroup_type = "all") %>%
  select(-c(na_pop, county_pop)) %>%
  #add in geoid so on bind_rows, all rows have geoid
  mutate(geoid = paste0(state, county))

```

### Subgroups

Create an NA indicator counting population of tracts where either index air quality or poverty_type are missing.
```{r}
haz_index_pov <- haz_index_county_acs %>% 
  mutate(na_pop = if_else(is.na(index_air_quality) | is.na(poverty_type), total_pop, 0))
```
Calculate county/poverty type index Create a weighting indicator so weights can be applied to the appropriate subgroup.
*Note* this is a change from the original version. The previous program weighted each tract by the count of individuals in poverty for high_poverty tracts and the county of indivdiuals not in poverty in not_high_poverty tracts. This version considers the total population of the tracts and weights based on that. 
```{r}
haz_index_sub_poverty <- haz_index_pov %>% 
  group_by(year, state, county, poverty_type) %>%
  summarise(index_air_quality = weighted.mean(index_air_quality, total_pop, na.rm = TRUE),
            na_pop = sum(na_pop, na.rm = TRUE),
            subgroup_pop = sum(total_pop, na.rm=TRUE)
  ) %>%
  ungroup()%>%
  mutate(na_perc = na_pop / subgroup_pop) %>%
  select(-c(na_pop, subgroup_pop)) %>%
  filter(!is.na(poverty_type))
```

Expand data set for every county/poverty_type
```{r}
haz_index_county_sub_expand  <- haz_index_county_acs  %>%
  expand(year, state, county, poverty_type)
```

Join dataset on expanded dataset, join with geo varibale, and add subgroup type variables

```{r}

pov_environment_exp19 <- haz_index_county_sub_expand %>% 
  left_join(haz_index_sub_poverty %>%
                                     select(year, state, county, poverty_type, index_air_quality, na_perc),
                                   by=c("year", 
                                        "state",
                                        "county",
                                        "poverty_type")) %>%
  rename(subgroup = poverty_type) %>%
  mutate(subgroup_type = "poverty") %>%
  filter(!is.na(subgroup)) 

```

### Neighborhood racial majority

Create neigorhood racial majority weight.

```{r}
haz_by_race19 <- race_pov_enviro19 %>%
  mutate(weighting_ind = case_when(
    race_ind == "No Majority Race/Ethnicity" ~ total_pop,
    race_ind == "Majority Non-White" ~ poc,
    race_ind == "Majority White, Non-Hispanic" ~ wnh
  ),
  na_pop = if_else(is.na(index_air_quality) | is.na(race_ind), weighting_ind, 0)) 
```

Average county level hazard by race/ethnicity Create a weighting indicator so weights can be applied to the appropriate subgroup Weight the index by total population for tracts that have mixed race and ethnicity Weight by number of people of color for tracts that are majority non-white Weight by number of white, non-hispanic people for tracts that are majority white, non-hispanic Calculate missingness

```{r}
haz_by_race19 <- race_pov_enviro19 %>%
  group_by(state, county, race_ind) %>%
  summarise(index_air_quality = weighted.mean(index_air_quality, weighting_ind, na.rm = TRUE),
            na_pop = sum(na_pop, na.rm = TRUE),
            subgroup_pop = sum(weighting_ind, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(geoid = str_c(state, county),
         na_perc = na_pop / subgroup_pop) %>%
  select(-c(na_pop, subgroup_pop)) %>%
  filter(!is.na(race_ind))  


```

expand dataset for every county/race/ethnicity

```{r}
expand_race19 <- haz_by_race19 %>%
  expand(geoid, race_ind)
```

Join to expanded, add geo variables, and add subgroup variables

```{r}
haz_by_race_exp19 <- left_join(expand_race19, 
                               haz_by_race19 %>%
                                 select(geoid, race_ind, index_air_quality, na_perc),
                               by=c("geoid", "race_ind")) %>%
  left_join(state_county19, by = "geoid") %>%
  rename(subgroup = race_ind) %>%
  mutate(subgroup_type = "race-ethnicity")
```

Append data. Final data should be 18,852 (3,142 counties\*6 sub-groups)

```{r}

bind_data_cnty19 <- all_environment19 %>% 
  bind_rows(pov_environment_exp19) %>%
  bind_rows(haz_by_race_exp19)


```

Match file to data standards

```{r}
final_data_cnty_sub19 <- bind_data_cnty19 %>%
  mutate(year = 2019) %>%
  #create quality variable where quality is 2 if value is missing by more than 5 percent
  mutate(environmental_quality = if_else(na_perc >= .05,2,1)) %>%
  #select(-na_perc) %>%
  arrange(year,
          state,
          county,
          subgroup_type,
          subgroup) %>%
  select(year, state, county, subgroup_type, subgroup, index_air_quality, environmental_quality) 
```

Round environmental indicator to nearest integer

```{r}
final_data_cnty_sub19 <- final_data_cnty_sub19 %>% 
  mutate(index_air_quality = round(index_air_quality, digits = 0))
```

Create all version of data.

```{r}
data_cnty19_final <- final_data_cnty_sub19 %>%
  filter(subgroup == "All")
```

## Crosswalk palce

Crosswalk tract-level data to places.

Read in crosswalk data and create GEOID that is comprised of state, county and tract.

```{r}

crosswalk_city <- read_csv(here::here("geographic-crosswalks/data", "geocorr2018_tract_to_place.csv")) %>% 
  mutate(county = str_sub(county, start = -3L, end = -1L),
         state = str_pad(state, 2, side = "left", pad = "0"),
         tract = tract * 100,
         tract = str_pad(tract, 6, side = "left", pad = "0"),
         GEOID = paste0(state, county, tract)) %>% 
  select(place = placefp, GEOID, afact)

```

Pad the place variable with a leading zero.

```{r}

crosswalk_city <- crosswalk_city %>% 
  mutate(place = str_pad(place, 5, side = "left", pad = "0")) %>% 
  select(place, GEOID, afact)

```

Merge the environmental index tract level data onto the city crosswalk file.

```{r}

tract_place_haz19 <- crosswalk_city %>% 
  left_join(race_pov_enviro19, by = "GEOID") %>%
  mutate(place = as.character(place)) 


anti_join(x = race_pov_enviro19, y = crosswalk_city, by = "GEOID") %>%
  filter(total_pop > 0)

```

## Create place level index

### 2019

Import places/pop file and prep to limit to population cutoff places.

```{r}
state_places_pop19 <- read_csv(here::here("geographic-crosswalks/data", "place-populations.csv")) %>% 
  filter(year == 2019)

```

Create "All" observations calculate place population for tracts and index_air_quality weighting by amount of tract in place and tract total population

```{r}

all_enviro_place19 <- tract_place_haz19 %>%
  mutate(tract_pop = (total_pop*afact)) %>% #to account for the fact that only part of the tract population is in the place
  group_by(state, place) %>%
  summarise(index_air_quality = weighted.mean(index_air_quality, tract_pop, na.rm = TRUE),
        na_pop = sum(na_pop * afact),
        place_pop = sum (tract_pop)) %>% 
        ungroup()
```

Add a variable with percent of population missing for each place

```{r}
all_enviro_place19 <- all_enviro_place19 %>%
  mutate(na_perc = na_pop / place_pop,
      subgroup = "All",
      subgroup_type = "all") %>%
select(-c(na_pop, place_pop))
```

Create a GEOID for later.

```{r}

all_enviro_place19 <- all_enviro_place19 %>% 
  mutate(geoid = paste0(state, place))

```

Create place level weighted index by poverty level.

```{r}

pov_enviro_place19 <- tract_place_haz19 %>%
  mutate(weighting_ind = case_when(poverty_type == "High Poverty" ~ poverty,
                                    poverty_type == "Not High Poverty" ~ (total_pov - poverty)),
          na_pop = if_else(is.na(index_air_quality) | is.na(poverty_type), weighting_ind, 0)) %>%
  group_by(state, place, poverty_type) %>%
  summarise(index_air_quality = weighted.mean(index_air_quality, weighting_ind*afact, na.rm = TRUE), #Multiplied weight by % in Tract
            na_pop = sum(na_pop*afact, na.rm = TRUE), 
            subgroup_pop = sum(weighting_ind, na.rm=TRUE)
  ) %>%
  ungroup()%>%
  mutate(geoid = str_c(state,place),
          na_perc = na_pop / subgroup_pop) %>%
  select(-c(na_pop, subgroup_pop))


```

Create a file with unique states and places.

```{r}

state_place19 <- tract_place_haz19 %>%
  transmute(geoid = str_c(state, place), state, place) %>%
  distinct()%>%
  filter(!is.na(geoid)) 

```

Expand poverty/place data set for every place and poverty type

```{r}
expand_pov_place19 <- pov_enviro_place19 %>%
  expand(geoid, poverty_type)
```

Join poverty data set.

```{r}
pov_env_exp_place19 <- left_join(expand_pov_place19,
                                        pov_enviro_place19 %>%
                                        select(geoid, poverty_type, index_air_quality, na_perc),
                                        by=c("geoid",
                                            "poverty_type")) %>%
  left_join(state_place19, by = "geoid") %>%
  rename(subgroup = poverty_type) %>%
  mutate(subgroup_type = "poverty") %>%
  filter(!is.na(subgroup))
```

Create place level weighted index by race/ethnicity majority.

```{r}

haz_by_race_place19 <- tract_place_haz19 %>%
  mutate(weighting_ind = case_when(race_ind == "No Majority Race/Ethnicity" ~ total_pop,
                                    race_ind == "Majority Non-White" ~ poc,
                                    race_ind == "Majority White, Non-Hispanic" ~wnh),
          na_pop = if_else(is.na(index_air_quality) | is.na(race_ind), weighting_ind, 0)) %>%
  group_by(state, place, race_ind) %>%
  summarise(index_air_quality = weighted.mean(index_air_quality, weighting_ind*afact, na.rm = TRUE), ##[CHECK - weight by afact??]##
            na_pop = sum(na_pop*afact, na.rm = TRUE), 
            subgroup_pop = sum(weighting_ind*afact, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(geoid = str_c(state, place),
          na_perc = na_pop / subgroup_pop) %>%  
  select(-c(na_pop, subgroup_pop)) 

```

Expand data set for every place/race/ethnicity

```{r}

expand_race_place19 <- haz_by_race_place19 %>%
  expand(geoid, race_ind)

```

Join to expanded, add GEO variables, and add subgroup variables

```{r}

haz_by_race_exp_place19 <- left_join(expand_race_place19,
                                      haz_by_race_place19 %>%
                                        select(geoid, race_ind, index_air_quality, na_perc),
                                        by=c("geoid", "race_ind")) %>%
  left_join(state_place19, by = "geoid") %>%
  rename(subgroup = race_ind) %>%
  mutate(subgroup_type = "race-ethnicity") %>%
  filter(!is.na(subgroup))
  

```

Append data

```{r}

bind_data_place19 <- all_enviro_place19 %>%
  bind_rows(pov_env_exp_place19) %>%
  bind_rows(haz_by_race_exp_place19) %>%
  mutate(
    environmental_quality = if_else(na_perc >= .05,2,1),
    year = 2019
          ) %>%
  select(-na_perc) 

```

Keep only the places in the places_pop19 file

```{r}

final_data_place19 <- bind_data_place19 %>%
  filter(geoid %in% state_places_pop19$geoid) %>%
  filter(!is.na(subgroup)) 

```

Select to match datastructure

```{r}

final_data_place19 <-  final_data_place19 %>%
 arrange(year,
          state,
          place,
          subgroup_type,
          subgroup)%>%
  select(year, state, place, subgroup_type, subgroup, index_air_quality, environmental_quality) 

```

Round environmental indicator to nearest integer

```{r}

final_data_place19 <- final_data_place19 %>% 
  mutate(index_air_quality = round(index_air_quality, digits = 0))

```

Crate a file with just the all subgroup

```{r}
final_place_all19 <- final_data_place19 %>%
  filter(subgroup == "All")
```

#save files

## County

Save county all and county subgroup data for 2019

```{r}
write_csv(data_cnty19_final,"06_neighborhoods/environment/data/output/environment_county19.csv")
write_csv(final_data_cnty_sub19, "06_neighborhoods/environment/data/output/environment_county_sub19.csv")
```

## Place

Save place all and place subgroup data for 2019

```{r}
write_csv(final_place_all19,"06_neighborhoods/environment/data/output/environment_place19.csv")
write_csv(final_data_place19, "06_neighborhoods/environment/data/output/environment_place_sub19.csv")
```
