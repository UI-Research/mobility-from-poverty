---
title: "Transit Trips and Transportation Costs -- County -- Subgroups"
author: "Tina Chelidze and Aaron R. Williams"
date: today
format:
  html:
    toc: true
    toc_float: true
    embed-resources: true
    code-fold: show
execute: 
  warning: false
editor_options: 
  chunk_output_type: console
---

::: {.callout-tip}
Raw data pulled from https://htaindex.cnt.org/download/ The Housing and Transportation (H+T) Affordability Index from the Center for Neighborhood Technology (CNT)
:::

::: {.callout-tip}
*User Notice: This program requires downloading raw files from the Metrics_2024_round Box folder prior to running. See details under the Read Data section.*

:::

## Setup

### Load Packages

```{r}
library(tidyverse)
library(tidycensus)
library(here)

source(here("functions", "testing", "evaluate_final_data.R"))

theme_set(theme_minimal())

```

### Read data

The data from CNT cannot be easily read directly into this program.
Before running, please download the entirety of the folders listed below from the following [Box
folder](https://urbanorg.app.box.com/folder/250262697073) into the
repository folder. You may be required to unzip the folders but keep the raw files in their folders. 
`"mobility-from-poverty\06_neighborhoods\transportation\data"`

-   2015_tract
-   2019_tract

```{r}
tractpath15 <- list.files(
  path = here("06_neighborhoods",
              "Transportation", 
              "data", 
              "2015_tract"), 
  pattern = "*.csv", 
  full.names = TRUE
)

tractpath19 <- list.files(
  path = here("06_neighborhoods",
              "Transportation", 
              "data", 
              "2019_tract"), 
  pattern = "*.csv", 
  full.names = TRUE
)

transportation_tracts <- bind_rows(
  `2015` = map_df(tractpath15, read_csv),
  `2019` = map_df(tractpath19, read_csv),
  .id = "year"
) |>
  mutate(year = as.numeric(year))

```

## Clean Transportation Data

Create correct FIPS columns.

```{r}
transportation_tracts <- transportation_tracts |>
  rename(GEOID = tract) |>
  mutate(
    state = substr(GEOID, start = 2, stop = 3),
    county = substr(GEOID, start = 4, stop = 6),
    tract = substr(GEOID, start = 7, stop = 12)
  )

```

```{r}
transportation_tracts <- transportation_tracts |>
  mutate(GEOID = paste0(state, county, tract))

```

Only keep variables of interest. 

```{r}
transportation_tracts <- transportation_tracts |>
  select(
    year, GEOID, state, county, tract, blkgrps, population, households, 
    count_transit_trips = transit_trips_80ami, 
    index_transportation_cost = t_80ami
  )

```

We drop tracts without households. Some of these tracts have population but the population must be in group quarters or on reservations. For example, one tract from the North Slope Borough in Alaska has people but no households. 

```{r}
transportation_tracts <- transportation_tracts |>
  filter(households > 0)

```

## Clean Census Data

```{r}
my_states <- fips_codes |> 
  filter(!state %in% c("PR", "UM", "VI", "GU", "AS", "MP")) |>
  pull(state) |>
  unique()

```

We pull `B00002_001`, which is the UNWEIGHTED SAMPLE HOUSING UNITS for the data quality measure. This series discontinues in the 2019, so we use 2018 as an approximation. 

```{r}
acs_sample_size <- bind_rows(
  `2015` = map_dfr(
    .x = my_states,
    .f = ~ get_acs(
      geography = "tract",
      state = .x,
      variables = "B00002_001",
      year = 2015,
      survey = "acs5",
      output = "wide"
    )
  ),
  `2019` = map_dfr(
    .x = my_states,
    .f = ~ get_acs(
      geography = "tract",
      state = .x,
      variables = "B00002_001",
      year = 2018,
      survey = "acs5",
      output = "wide"
    )
  ),
  .id = "year"
) |>
  rename(sample_size = B00002_001E) |>
  mutate(year = as.numeric(year))
 
```

`sample_size` is `NA` in some tracts that are reported in the transportation data. Exploration shows that some of these tracts bounced between a few households and no households during this time period. We impute `1` as the sample size for all of these households. 

```{r}
acs_sample_size <- acs_sample_size |>
  replace_na(list(sample_size = 1))

```

We need to pull counts of different races and ethnicities at the census tract level to identify tracts for the subgroup analysis. To do this, we pull detailed information and roll up the categories. The following table shows the race/ethnicity categories and the combination of ACS variables into our new variables.

| Variable.    | Depth       | Description    | New Variable   |
| -----|----|--------------------------------- | -------------- |
| `B03002_001` | 1 | Estimate!!Total | `total_population`   |
| `B03002_002` | 2 | Estimate!!Total!!Not Hispanic or Latino | `NA` |
| `B03002_003` | 3 | Estimate!!Total!!Not Hispanic or Latino!!White alone | `whitenh`  |
| `B03002_004` | 3 | Estimate!!Total!!Not Hispanic or Latino!!Black or African American alone | `poc`   |
| `B03002_005` | 3 | Estimate!!Total!!Not Hispanic or Latino!!American Indian and Alaska Native alone | `poc`   |
| `B03002_006` | 3 | Estimate!!Total!!Not Hispanic or Latino!!Asian alone | `poc`   |
| `B03002_007` | 3 | Estimate!!Total!!Not Hispanic or Latino!!Native Hawaiian and Other Pacific Islander alone | `poc`   |
| `B03002_008` | 3 | Estimate!!Total!!Not Hispanic or Latino!!Some other race alone | `poc`   |
| `B03002_009` | 3 | Estimate!!Total!!Not Hispanic or Latino!!Two or more races | `poc`  |
| `B03002_010` | 4 | Estimate!!Total!!Not Hispanic or Latino!!Two or more races!!Two races including Some other race | `NA` |
| `B03002_011` | 4 | Estimate!!Total!!Not Hispanic or Latino!!Two or more races!!Two races excluding Some other race, and three or more races | `NA` |
| `B03002_012` | 2 | Estimate!!Total!!Hispanic or Latino | `poc` |
| `B03002_013` | 3 | Estimate!!Total!!Hispanic or Latino!!White alone | `NA` |
| `B03002_014` | 3 | Estimate!!Total!!Hispanic or Latino!!Black or African American alone | `NA` |
| `B03002_015` | 3 | Estimate!!Total!!Hispanic or Latino!!American Indian and Alaska Native alone | `NA` |
| `B03002_016` | 3 | Estimate!!Total!!Hispanic or Latino!!Asian alone | `NA` |
| `B03002_017` | 3 | Estimate!!Total!!Hispanic or Latino!!Native Hawaiian and Other Pacific Islander alone | `NA` |
| `B03002_018` | 3 | Estimate!!Total!!Hispanic or Latino!!Some other race alone | `NA` |
| `B03002_019` | 3 | Estimate!!Total!!Hispanic or Latino!!Two or more races | `NA` |
| `B03002_020` | 4 | Estimate!!Total!!Hispanic or Latino!!Two or more races!!Two races including Some other race | `NA` |
| `B03002_021` | 4 | Estimate!!Total!!Hispanic or Latino!!Two or more races!!Two races excluding Some other race, and three or more races | `NA` |

```{r}
acs_tract_pop15 <- map_dfr(
  .x = my_states,
  .f = ~ get_acs(
    geography = "tract",
    state = .x,
    table = "B03002",
    year = 2015,
    survey = "acs5",
    output = "wide"
  )
)

acs_tract_pop19 <- map_dfr(
  .x = my_states,
  .f = ~ get_acs(
    geography = "tract",
    state = .x,
    table = "B03002",
    year = 2019,
    survey = "acs5",
    output = "wide"
  )
)

acs_tracts <- bind_rows(
  `2015` = acs_tract_pop15,
  `2019` = acs_tract_pop19,
  .id = "year"
) |>
  mutate(year = as.numeric(year))

acs_tracts <- acs_tracts |>
  mutate(
    state = substr(GEOID, start = 1, stop = 2),
    county = substr(GEOID, start = 3, stop = 5),
    tract = substr(GEOID, start = 6, stop = 11)
  )

```

We join the unweighted sample size information to the main demographic information. 

```{r}
acs_tracts <- full_join(
  acs_tracts,
  acs_sample_size,
  by = c("year", "GEOID"), 
  relationship = "one-to-one"
)

```

Rename columns for clarity and calculate counts of people by different races and ethnicities. 

```{r}
acs_tracts <- acs_tracts |>  
  rename(
    total_population = B03002_001E,
    non_hispanic = B03002_002E,
    white_nh = B03002_003E,
    hispanic = B03002_012E
  ) |>
  mutate(
    poc_non_hispanic =     
      B03002_004E +
      B03002_005E +
      B03002_006E +
      B03002_007E +
      B03002_008E +
      B03002_009E
  ) |>
  mutate(poc = poc_non_hispanic + hispanic)

stopifnot(
  acs_tracts |>
    filter(total_population != (white_nh + poc_non_hispanic + hispanic)) |>
    nrow() == 0
)

stopifnot(
  acs_tracts |>
    filter(total_population != (white_nh + poc)) |>
    nrow() == 0
)

```

Keep only vars we want.

```{r}
acs_tracts <- acs_tracts |>
  select(year, GEOID, state, county, tract, total_population, white_nh, poc, sample_size)

```

## Merge Data

We join the ACS demographic information to the transportation information. 

```{r}
combined_tracts <- left_join(
  transportation_tracts,
  acs_tracts, 
  by = c("year", "GEOID", "state", "county", "tract")
)

```

No tracts with transportation data are missing demographic data. There are demographic tracts without transportation information but this is expected because of empty tracts and tracts without households. A few tracts have `sample_size > 0`. We speculate this is because of using different ACS years.

```{r}
anti_join(
  transportation_tracts,
  acs_tracts, 
  by = c("year", "GEOID", "state", "county", "tract")
)

anti_join(
  acs_tracts, 
  transportation_tracts, 
  by = c("year", "GEOID", "state", "county", "tract")
) |>
  filter(total_population > 0)

anti_join(
  acs_tracts, 
  transportation_tracts, 
  by = c("year", "GEOID", "state", "county", "tract")
) |>
  filter(sample_size > 0) |>
  arrange(desc(sample_size))

```

## Calculate race category

For each tract, ID the race category by calculating the proportion White, Non-Hispanic and the proportion of every other race and ethnicity. 

```{r}
combined_tracts <- combined_tracts |>
  mutate(
    prop_white_nh = white_nh / total_population,
    prop_poc = poc / total_population
  )

stopifnot(
  combined_tracts |>
    filter(prop_white_nh + prop_poc != 1) |>
    nrow() == 0
)

```

Assign race-category for each tract. These assignments should align with the debt metric.

```{r}
combined_tracts <- combined_tracts |>
  mutate(
    subgroup = case_when(
      total_population == 0 ~ "No population",
      prop_white_nh >= 0.6 ~ "White neighborhoods",
      prop_poc >= 0.6 ~ "Neighborhoods of color",
      prop_white_nh >= 0.4 | prop_poc >= 0.4 ~ "Mixed neighborhoods",
      prop_white_nh < 0.4 & prop_poc < 0.4 ~ as.character(NA)
    )
  ) 

combined_tracts |>
  count(subgroup)

```

## Calculate metrics

We average census tracts to the county-race/ethnicity group with weights for the number of households in each tract. 

```{r}
transportation_county_all <- combined_tracts |>
  filter(subgroup != "No population") |>
  group_by(year, state, county) |>
  summarize(
    count_transit_trips = weighted.mean(x = count_transit_trips, w = households),
    index_transportation_cost = weighted.mean(x = index_transportation_cost, w = households),
    households = sum(households),
    sample_size = sum(sample_size)
  ) |>
  mutate(
    subgroup_type = "all",
    subgroup = "All"
  ) |>
  ungroup()

transportation_county_subgroup <- combined_tracts |>
  filter(subgroup != "No population") |>
  group_by(year, state, county, subgroup) |>
  summarize(
    count_transit_trips = weighted.mean(x = count_transit_trips, w = households),
    index_transportation_cost = weighted.mean(x = index_transportation_cost, w = households),
    households = sum(households),
    sample_size = sum(sample_size)
  ) |>
  mutate(
    subgroup_type = "race-ethnicity"
  ) |>
  ungroup()

transportation_county <- bind_rows(
  transportation_county_all, 
  transportation_county_subgroup
)

```

Some county-race/ethnicity groups are missing. This is because some race/ethnicity groups don't exist in each county. We load the target geography file, join our statistics to the target geography file, and then add zeros for household sizes.

```{r}
target_statistics <- read_csv(here("geographic-crosswalks", "data", "county-populations.csv")) |>
  filter(year %in% c(2015, 2019)) |>
  select(year, state, county) |>
  expand_grid(subgroup = c("All", "Neighborhoods of color", "White neighborhoods", "Mixed neighborhoods")) |>
  mutate(subgroup_type = if_else(subgroup == "All", "all", "race-ethnicity"))

transportation_county <- full_join(
  target_statistics,
  transportation_county,
  by = c("year", "state", "county", "subgroup_type", "subgroup")
)

transportation_county <- transportation_county |>
  mutate(households = if_else(is.na(households), 0, households))

```

## Transit Trips Quality Control Checks

### Missing Data

```{r}
transportation_county |>
  filter(is.na(count_transit_trips)) |>
  count(subgroup)

```

### Distribution

Use stopifnot to check if all values in `transportation_county` are non-negative.

```{r}
stopifnot(min(transportation_county$count_transit_trips, na.rm = TRUE) >= 0)
```

Create a histogram.

```{r}
ggplot(transportation_county, aes(x = count_transit_trips)) +
  geom_histogram(binwidth = 5) + 
  facet_grid(year ~ subgroup) +
  labs(
    x = "Annual Transit Trips for the Regional Moderate Income Household", 
    y = "number of counties"
  )
```

Makes sense for most counties to fall in really low transit trip numbers since most of the US has no public infrastructure that can be used for daily transport.

Look at summary stats

```{r}
summary(transportation_county$count_transit_trips)
```

Examine extreme values

```{r}
transportation_county |>
  group_by(year) |>
  slice_max(n = 10, order_by = count_transit_trips) |>
  select(year, state, county, subgroup, count_transit_trips)

```

### Change

We look at the change from 2015 to 2019. Transit trips changes a lot, which may cause us to question the data quality. 

```{r}
transportation_county |>
  select(state, county, year, subgroup, households, count_transit_trips) |>
  pivot_wider(
    names_from = year, 
    values_from = c(households, count_transit_trips)
  ) |>
  mutate(size = if_else(households_2019 > 200000, "Large counties", "Small counties")) |>
  ggplot(aes(count_transit_trips_2015, count_transit_trips_2019, size = households_2019)) +
  geom_point(alpha = 0.1) +
  facet_grid(size ~ subgroup) +
  coord_equal() +
  labs(subtitle = "Large counties have at least 200,000 households")

transportation_county |>
  group_by(state, county, subgroup) |>
  mutate(change_count_transit_trips = count_transit_trips - lag(count_transit_trips)) |>
  ungroup() |>
  filter(year == 2019) |>
  slice_max(order_by = abs(change_count_transit_trips), n = 10) |>
  select(year, state, county, subgroup, change_count_transit_trips)

```

## Cost Quality Control Checks

### Missing Data

```{r}
transportation_county |>
  filter(is.na(index_transportation_cost))

```

### Distribution

Use stopifnot to check if all values in `transportation_county` are non-negative.

```{r}
stopifnot(min(transportation_county$index_transportation_cost, na.rm = TRUE) >= 0)
```

Create a histogram.

```{r}
ggplot(transportation_county, aes(x = index_transportation_cost)) +
  geom_histogram(binwidth = 5) + 
  facet_grid(year ~ subgroup) +
  labs(
    x = "Annual Transportation Costs for the Regional Moderate Income Household", 
    y = "number of counties"
  )

```

Look at summary stats

```{r}
summary(transportation_county$index_transportation_cost)
```

Examine extreme values

```{r}
transportation_county |>
  group_by(year) |>
  slice_max(n = 10, order_by = index_transportation_cost) |>
  select(year, state, county, subgroup, index_transportation_cost)

```

### Change

We look at the change from 2015 to 2019. Transportation costs are very stable during this time period.

```{r}
transportation_county |>
  select(state, county, year, subgroup, households, index_transportation_cost) |>
  pivot_wider(
    names_from = year, 
    values_from = c(households, index_transportation_cost)
  ) |>
  mutate(size = if_else(households_2019 > 200000, "Large counties", "Small counties")) |>
  ggplot(aes(index_transportation_cost_2015, index_transportation_cost_2019, size = households_2019)) +
  geom_point(alpha = 0.1) +
  facet_wrap(~ size) +
  coord_equal() +
  labs(subtitle = "Large counties have at least 200,000 households")


transportation_county |>
  group_by(state, county, subgroup) |>
  mutate(change_index_transportation_cost = index_transportation_cost - lag(index_transportation_cost)) |>
  ungroup() |>
  filter(year == 2019) |>
  slice_max(order_by = abs(change_index_transportation_cost), n = 10)  |>
  select(year, state, county, subgroup, index_transportation_cost)

```

## Data Quality Marker

Determine data quality cutoffs based on number of observations (all at the HH level for these values).

```{r}
summary(transportation_county$households) 

```

We use 30 households as a quality cutoff. Estimates with fewer than 30 responses receive a data quality of 3 and everything else gets data quality of 1. 

```{r}
transportation_county <- transportation_county |>
  mutate(
    count_transit_trips_quality = if_else(sample_size > 30, true = 1, false = 3),
    index_transportation_cost_quality = if_else(sample_size > 30, true = 1, false = 3)
  ) |>
  mutate(
    count_transit_trips_quality = if_else(is.na(count_transit_trips), NA, count_transit_trips_quality),
    index_transportation_cost_quality = if_else(is.na(index_transportation_cost), NA, index_transportation_cost_quality)
  )

stopifnot(
  transportation_county |>
    filter(
      (is.na(count_transit_trips) | is.na(index_transportation_cost)) &
        (!is.na(count_transit_trips_quality) | !is.na(index_transportation_cost_quality))
    ) |>
    nrow() == 0
)

```

## Export final files

Keep variables of interest and order them appropriately.

```{r}
final_data <- transportation_county |>
  select(year, state, county, subgroup_type, subgroup, count_transit_trips, count_transit_trips_quality, index_transportation_cost, index_transportation_cost_quality) 

```

Run the evaluation function. 

```{r}
evaluate_final_data(
  exp_form_path = here("06_neighborhoods", 
       "Transportation", 
       "final", 
       "final_data_evaluation_form.csv"), 
  data = final_data, 
  geography = "county",
  confidence_intervals = FALSE, 
  subgroups = TRUE
)

```

```{r}
final_data |>
  arrange(year, state, county) |>
  write_csv(
    here("06_neighborhoods",
         "Transportation",
         "final",
         "transportation_subgroup_county.csv")
  )

```
